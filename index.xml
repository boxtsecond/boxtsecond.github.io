<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Bo&#39;s Blog</title>
        <link>https://boxtsecond.github.io/</link>
        <description>Recent content on Bo&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 23 Aug 2023 23:19:41 +0800</lastBuildDate><atom:link href="https://boxtsecond.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>数据结构（九）字符串匹配</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link>
        <pubDate>Wed, 23 Aug 2023 23:19:41 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid>
        <description>&lt;h2 id=&#34;brute-force-暴力匹配算法朴素匹配算法&#34;&gt;Brute Force 暴力匹配算法/朴素匹配算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;思想
&lt;ul&gt;
&lt;li&gt;在主串中，匹配模式串。若主串的长度是 n，模式串的长度是 m，则 n &amp;gt;= m。主串可以按照模式串的长度 m，得出 n - m + 1 个子串。&lt;/li&gt;
&lt;li&gt;将主串中起始位置为 0，长度为 m 的子串 x，与模式串的每一位字符依次比较。若相等则继续，不相等则进行下一步。&lt;/li&gt;
&lt;li&gt;若不匹配，则将主串中的起始位置加 1。循坏执行上一步，直到主串的起始位置大于 n - m + 1 或 匹配成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度：O（n*m）&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;思路简单，代码易实现，维护简单，是最常见的处理小规模的字符串匹配算法&lt;/li&gt;
&lt;li&gt;在实际应用中，时间复杂度往往远低于 O（n*m）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rabin-karp&#34;&gt;Rabin-Karp&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;思想
&lt;ul&gt;
&lt;li&gt;在 BF 算法上进行优化，利用哈希算法减少匹配时的时间复杂度，但是匹配的次数没有减少。&lt;/li&gt;
&lt;li&gt;将主串中得出的 n - m + 1 个子串分别求哈希值。依次和模式串的哈希值比较。&lt;/li&gt;
&lt;li&gt;有技巧地计算子串的哈希值
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设要匹配的字符串的字符集中包含 k 个字符，使用 k 进制来表示一个子串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将代表子串的 k 进制数字转换成十进制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在相邻的两个子串的哈希值计算公式存在以下关系：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rk.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rk.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;rabin-karp&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;rabin-karp&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B = （A - 第一位的 k 进制值） * k + 最后一位的 k 进制值&lt;/li&gt;
&lt;li&gt;第一位的 k 进制 = （km-1）* 此字符表示的 k 进制的数字&lt;/li&gt;
&lt;li&gt;km 可以提前算好存储在数组中，下标为 m 的值为 km&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若可能存在哈希冲突，则将哈希值相等的子串和模式串再一次进行比较&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间复杂度：O（n），当可能存在大量的哈希冲突时，则退化为 O（n*m）&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;可能会有散列冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;boyer-moore-bm-算法&#34;&gt;Boyer-Moore BM 算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;目的
&lt;ul&gt;
&lt;li&gt;尽可能地一次性跳过多个字符，&lt;strong&gt;从后往前的比较字符&lt;/strong&gt;，用来减少 BF（暴力匹配）算法的匹配次数，以提升算法的效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;思想
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;坏字符规则&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_bad.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_bad.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;坏字符规则&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;坏字符规则&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;从后往前&lt;/strong&gt;的将模式串和主串进行匹配&lt;/li&gt;
&lt;li&gt;找到主串“坏字符”对应下标
&lt;ul&gt;
&lt;li&gt;若存在不匹配的字符，将主串中对应的字符标记为“坏字符”，并记录“坏字符”的位置为 si&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;找到模式串中另一个与主串中“坏字符”相等的字符
&lt;ul&gt;
&lt;li&gt;在模式串中查找是否存在另一个与主串中的“坏字符”相等的字符&lt;/li&gt;
&lt;li&gt;若模式串中存在一个或多个与主串中“坏字符”相等的字符，则记录下最后出现的位置为 xi（以免跳过太多字符，导致错过可以正确匹配的字符），跳过 si - xi 个字符&lt;/li&gt;
&lt;li&gt;若不存在，则直接跳过模式串长度个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意事项&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;si - xi 有可能出现负数的情况&lt;/li&gt;
&lt;li&gt;例如：主串为 aaaaaa，模式串为 baa，当比较模式串中的 b 时，主串中“坏字符”的位置为 0，模式串中的位置为 2（取最后一个），则跳过字符的个数为 0 - 2 = -2&lt;/li&gt;
&lt;li&gt;为了避免出现跳跃负数个字符，还需要“好后缀规则”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好后缀规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从后往前&lt;/strong&gt;的匹配模式串和主串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到主串中的“好后缀”{u}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个不匹配字符之后的字符串，就是“好后缀”{u}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到模式串中另一个与主串中“好后缀”相等的字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在模式串中查找是否存在与主串中“好后缀”相等的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果存在一个或多个与主串中“好后缀”相等的字符串，则找到最后一个相等的字符串 {u*}，将 {u*} 跳跃对应到 {u} 的位置&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;好后缀规则&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;好后缀规则&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果模式串中不存在与“好后缀”相等的字符串，则需要判断匹配到的好后缀中，在模式串中是否存在相等的前缀子串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果模式串中存在后缀子串和前缀子串相等的字符串，则跳跃到前缀子串最长能匹配到的位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果模式串中不存在后缀子串和前缀子串相等的字符串，则跳跃模式串长度个字符&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_1.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_1.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;好后缀规则&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;好后缀规则&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当坏字符规则和好后缀规则同时存在时，可判断这两种情况下得出的跳跃字符个数，选择较大的跳过。可以避免坏字符规则出现负数的情况。&lt;/li&gt;
&lt;li&gt;当内存条件受限时，可只采用好后缀规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用
&lt;ul&gt;
&lt;li&gt;文本中的查找功能&lt;/li&gt;
&lt;li&gt;linux grep 的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bm-算法的代码分析&#34;&gt;BM 算法的代码分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;坏字符规则
&lt;ul&gt;
&lt;li&gt;需要找到“坏字符”在模式串中最后出现的位置，即 xi
&lt;ol&gt;
&lt;li&gt;每次将“坏字符”在模式串中进行顺序查找（效率太低）&lt;/li&gt;
&lt;li&gt;使用散列表存储模式串每个字符出现的最后位置，可以使用数组或者对象，默认值是 -1，即在模式串中没有此字符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;好后缀规则
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;需要找到“好后缀”在模式串中，除本身外最后出现的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 suffix 数组，数组的下标表示“好后缀”的长度，数组中的值表示除本身外最后出现的位置&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_2.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_2.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;好后缀&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;好后缀&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要找到与模式串的前缀子串与模式串后缀子串重合的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 prefix 数组，数组的下标表示后缀子串的长度，数组中的值表示是否存在后缀子串与前缀子串相等的字符串&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_3.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_3.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;好后缀&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;好后缀&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 suffix 对应后缀子串长度的值不为 -1，则表示模式串中存在（除本身之外）与“好后缀”相等的字符串，则将模式串中最后出现的“好后缀”字符串对应到主串中的“好后缀”字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若主串中“坏字符”位置为 j，模式串的长度为 m&lt;/li&gt;
&lt;li&gt;主串中“好后缀”字符串的起始位置为 j + 1，“好后缀”长度为 k，k = m - j - 1&lt;/li&gt;
&lt;li&gt;需要移动的位数为：j + 1 - suffix[k]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 suffix 对应后缀子串长度的值为 -1，即模式串中不存在（除本身之外）与“好后缀”相等的字符串，则判断 prefix 数组中，下标为 [ 0～好后缀长度 ] 的值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;倒序查找下标为 [ 0～好后缀长度 ]，找到符合条件最长的前缀子串&lt;/li&gt;
&lt;li&gt;如果 prefix 对应后缀子串长度的值为 false，则表示模式串的前缀子串不存在和后缀子串重合的字符串，则移动的位数为：模式串的长度 m&lt;/li&gt;
&lt;li&gt;如果 prefix 对应后缀子串长度的值为 true，即模式串的前缀子串存在和后缀子串重合的字符串，则移动的位数为：模式串的长度 m - prefix 的下标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何填充 suffix 和 prefix 数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式串的长度为 m，则模式串为 B [ 0，m - 1 ]&lt;/li&gt;
&lt;li&gt;将 B [ 0，m - 1 ] 分别与 B [ 0，i ] 求公共后缀子串，i 的取值为 0 ～ m - 2
&lt;ul&gt;
&lt;li&gt;如果公共后缀子串的长度为 k，则 suffix[k] = j，j 表示公共后缀子串的起始位置&lt;/li&gt;
&lt;li&gt;如果 j = 0，则表示模式串的后缀子串和前缀子串有重合，prefix[k] = true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_4.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/bm_good_4.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;好后缀&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;好后缀&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;knuth-morris-pratt-kmp-算法&#34;&gt;Knuth Morris Pratt KMP 算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能地一次性跳过多个字符，&lt;strong&gt;从前往后的比较字符&lt;/strong&gt;，用来减少 BF（暴力匹配）算法的匹配次数，以提升算法的效率&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在已经匹配的前缀子串 A 中，看看 A 的后缀子串有没有和 A 的前缀子串重合，如果有的话，重合的部分可以不用比较&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;思想&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;从前往后&lt;/strong&gt;的将模式串与主串进行匹配&lt;/li&gt;
&lt;li&gt;当出现不能匹配的“坏字符”时，将之前可以匹配到的字符串称为“好前缀”&lt;/li&gt;
&lt;li&gt;如果“好前缀”中的后缀子串和模式串的前缀子串有重合，则可以跳过重合的部分，继续依次比较后面的字符。将“好前缀”后缀子串中最长可匹配模式串的前缀子串，称为“最长可匹配后缀子串”，对应的前缀子串称为“最长可匹配前缀子串”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/kmp_1.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/kmp_1.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;kmp&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;kmp&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/kmp_2.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/kmp_2.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;kmp&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;kmp&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;kmp-算法的代码分析&#34;&gt;KMP 算法的代码分析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;求模式串中前缀子串的“最长可匹配前缀子串”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 next 数组（失效函数），数组的下标代表模式串的前缀子串的长度，数组中的值为这个前缀子串对应的“最长可匹配前缀子串”的结尾字符下标（或这个前缀子串的“最长可匹配前缀子串”的长度 - 1）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/kmp_3.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/kmp_3.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;kmp&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;kmp&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用动态规划来求 next 数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 next[i - 1] = k - 1，即 B[0，i - 1] 对应的“最长可匹配好前缀”为 B[0，k - 1]&lt;/li&gt;
&lt;li&gt;当 B[i] == B[k] 时，则 next[i] = next[i - 1] + 1，即 next[i] = k&lt;/li&gt;
&lt;li&gt;当 B[i] != B[k] 时
&lt;ul&gt;
&lt;li&gt;假设 B[i - 1] 存在一个“可匹配好后缀”（不是“最长可匹配好后缀”）为 B[x，i - 1]，则对应的“可匹配前缀子串”为 B[0，i - 1 - x]。如果 B[i] == B[i - x]，则说明 B[x，i] 是 B[0，i] 的“最长可匹配后缀子串”&lt;/li&gt;
&lt;li&gt;如果不存在 B[i] == B[i - x]，则说明 next[i] = -1，即不存在“最长可匹配前缀子串”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将模式串与主串依次匹配，当出现“坏字符”时，获取对应“好前缀”的 next 数组（失效函数）的值 n，主串的匹配位置不变，将模式串移动 n 位，继续匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;trie-树字典树&#34;&gt;Trie 树（字典树）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一组字符串复用公共前缀后，所构成的树形结构，当单个字符串结束时，需要将节点标识为结束（下图中的红色节点）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/trie.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/trie.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;trie&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;trie&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在确定的一组字符集中，频繁查找或匹配不同的字符串，如 &lt;strong&gt;关键字检测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在确定的一组字符集中，查找或匹配符合前缀的字符串，如 &lt;strong&gt;搜索框自动补全&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符集要求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符集中，字符串的公共前缀重合较多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;trie-树-的操作&#34;&gt;Trie 树 的操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;构建 Trie 树
&lt;ul&gt;
&lt;li&gt;根结点不存放任何字符，仅作为开始节点&lt;/li&gt;
&lt;li&gt;根据字符集中的字符串，存储为多叉树，相同公共前缀的字符串拥有相同的父节点
&lt;ul&gt;
&lt;li&gt;存储为多叉树的方法有很多，如 有序数组、跳表、红黑树等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将字符串的最后一个字符，标识为结束节点，结束节点可以是叶子结点，也可以是任意一个父节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 Trie 树中查找字符串
&lt;ul&gt;
&lt;li&gt;当要查找的字符串的最后一个字符在 Trie 树中标识为结束节点时，则匹配成功，否则为匹配失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;trie-树的优缺点&#34;&gt;Trie 树的优缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;在已确定的字符集中，且字符集中的字符串的公共前缀较多。适合频繁的查找能否匹配成功，复杂度为 O（k），k 为要查找的字符串的长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适合查找前缀匹配的字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;每个节点需要维护子节点的指针，数据块不连续，对缓存不友好，内存消耗大&lt;/li&gt;
&lt;li&gt;改进 Trie 树，使其内存消耗减少时，效率降低，且编码难度增大，不如直接使用红黑树
&lt;ul&gt;
&lt;li&gt;如 缩点优化
&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/trie_1.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/trie_1.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;trie&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;trie&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ac-自动机aho-corasick&#34;&gt;AC 自动机（Aho-Corasick）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;适用场景
&lt;ul&gt;
&lt;li&gt;适用于于多模式串匹配，即在一个主串中查找多个模式串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目的
&lt;ul&gt;
&lt;li&gt;类似于 KMP 算法，尽可能地一次性跳过多个字符，用于减少匹配次数&lt;/li&gt;
&lt;li&gt;一次性地寻找多个模式串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AC 自动机的本质就是在 Trie 树上添加类似 KMP 的 next 数组，只不过 AC 自动机的 next 数组是构建在 Trie 树上&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ac-自动机的操作&#34;&gt;AC 自动机的操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;构建 Trie 树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根结点不存放任何字符，仅作为开始节点&lt;/li&gt;
&lt;li&gt;根据字符集中的字符串，存储为多叉树，相同公共前缀的字符串拥有相同的父节点
&lt;ul&gt;
&lt;li&gt;存储为多叉树的方法有很多，如 有序数组、跳表、红黑树等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将字符串的最后一个字符，标识为结束节点，结束节点可以是叶子结点，也可以是任意一个父节点&lt;/li&gt;
&lt;li&gt;在结束节点上记录模式串的长度，匹配时使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Trie 树上构建失败指针&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;失败指针的意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入的字符与当前结点的所有孩子结点都不匹配时，AC 自动机的状态应该转移到的状态&lt;/li&gt;
&lt;li&gt;从根结点到当前结点所组成的字符串 与 整个 Trie 树 中的所有前缀 的最长公共部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根结点的失败指针为 NULL，指向自己，按层遍历整个 Trie 树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前结点对应的字符和当前结点父节点指向的失败指针的孩子结点对应的字符一致，则当前结点的失败指针指向当前结点父节点的失败指针的孩子结点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p.fail == q &amp;amp;&amp;amp; pc == qc，则 pc.fail = qc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/ac.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/ac.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;ac&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;ac&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前结点对应的字符和当前结点父节点指向的失败指针的孩子结点对应的字符不一致，比较当前结点对应的字符和父节点的失败指针的失败指针，直到找到失败指针的孩子结点对应的字符与之相等，如果不存在，则当前结点的失败指针指向根结点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p.fail = q &amp;amp;&amp;amp; pc != q.children，则令 q = q.fail，继续比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/ac_1.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/ac_1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;ac&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;ac&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 AC 自动机中匹配主串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前结点的指针从根结点开始，主串字符从 0 开始匹配&lt;/li&gt;
&lt;li&gt;匹配当前结点的孩子结点和当前主串字符
&lt;ul&gt;
&lt;li&gt;如果相等，则判断当前结点和当前结点的失败指针指向的结点，是否是字符串的结束字符
&lt;ul&gt;
&lt;li&gt;如果是，将匹配到的字符保存在结果集中&lt;/li&gt;
&lt;li&gt;如果不是，当前结点指向孩子结点，继续匹配主串字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果不相等，则判断当前结点的失败指针是否指向 NULL
&lt;ul&gt;
&lt;li&gt;如果是，则令当前结点的指针指向根结点，继续匹配主串字符&lt;/li&gt;
&lt;li&gt;如果不是，则令当前结点的指针指向当前结点失败指针的结点，继续匹配失败指针的孩子结点和当前主串字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>数据结构（八）基于图的其它算法</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95/</link>
        <pubDate>Wed, 23 Aug 2023 22:45:41 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h2 id=&#34;拓扑排序-topological-sorting&#34;&gt;拓扑排序 Topological Sorting&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;当一组数据间存在两两依赖关系，并且数据间不存在循环依赖的关系。如果要对这组数据进行排序，则可以使用拓扑排序&lt;/li&gt;
&lt;li&gt;拓扑排序是基于有向无环图的算法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要通过局部顺序来推导出全局顺序的&lt;/strong&gt;，使用拓扑排序来实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;拓扑排序的实现方式&#34;&gt;拓扑排序的实现方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kahn 算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 s 先于 t 执行，则添加一条 从 s 指向 t 的边&lt;/li&gt;
&lt;li&gt;若某个顶点的入度为 0，说明没有任何一个顶点需要先于此顶点执行，则此顶点可以先执行&lt;/li&gt;
&lt;li&gt;在图中找出入度为 0 的顶点，输出并在图中删除此顶点，也就是把这个顶点可达的顶点的入度都 - 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;若输出的顶点个数少于图中的顶点个数，并且图中还存在入度不为 0 的顶点，则说明此图中存在环&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFS 深度优先遍历算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造逆邻接表，如果 s 先于 t 执行，则添加一条 从 t 指向 s 的边&lt;/li&gt;
&lt;li&gt;递归的处理每个顶点，先输出这个顶点可到达的顶点后，再输入此顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dijkstra-最短路径算法&#34;&gt;Dijkstra 最短路径算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;单源最短路径算法&lt;/strong&gt;，即 求一个顶点到另一个顶点的最短路径&lt;/li&gt;
&lt;li&gt;Dijkstra 是基于有向有权图&lt;/li&gt;
&lt;li&gt;Dijkstra 的时间复杂度为 O（E * logV），E 表示边的个数，V 表示顶点个数&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dijkstra-算法的实现&#34;&gt;Dijkstra 算法的实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用邻接表（邻接矩阵）来表示有向有权图
&lt;ul&gt;
&lt;li&gt;每个结点包括起始顶点 s 、结束顶点 t 、权重 w，即 s -&amp;gt; t&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用一个数组来表示从顶点 s 到此顶点 n 的最小距离
&lt;ul&gt;
&lt;li&gt;每个结点包括起始顶点 s 、当前顶点 n 、s 到 n 的最小距离 dist&lt;/li&gt;
&lt;li&gt;初始起点顶点的 dist 为 0，其余顶点的初始 dist 的值为无限大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;根据 dist 构造一个小顶堆，每次优先获取 dist 最小的顶点
&lt;ul&gt;
&lt;li&gt;初始 dist 小顶堆只有起始顶点，遍历其余顶点时不断更新 dist 小顶堆&lt;/li&gt;
&lt;li&gt;dist 小顶堆中存放的是已经遍历过且计算出 dist 的顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用一个数组来表示此顶点是否已经被遍历过
&lt;ul&gt;
&lt;li&gt;如果已经遍历过，且发现到达此顶点的更短路径，则更新 dist 的小顶堆&lt;/li&gt;
&lt;li&gt;如果没遍历过，将此顶点加入到 dist 的小顶堆中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用一个数组来表示最短路径，记录每个顶点的前驱顶点&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dijkstra-的优化&#34;&gt;Dijkstra 的优化&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当在较大的地图上，计算两点之间的最短路径时
&lt;ul&gt;
&lt;li&gt;如果两点间的距离较近，可以在整个大地图中划分出一个小的区块，这个小区块可以覆盖这两个点，但是区域不会太大&lt;/li&gt;
&lt;li&gt;如果两点间的距离较远，可以把两点所在的大区域当作一个点，先计算两个大区域的路线，然后再细化每个阶段的小路线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算两点间所用最少时间
&lt;ul&gt;
&lt;li&gt;将边的权重改为经过这段路所需要的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算两点之间所经过最少红绿灯
&lt;ul&gt;
&lt;li&gt;将每条边的权重值改为 1，或者直接使用广度优先搜索算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dijkstra-算法的变形和应用&#34;&gt;Dijkstra 算法的变形和应用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;背景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单词经过翻译系统后，得到单词对应的释义及分数，分数代表翻译的可信程度。将句子中的单词翻译后相加，可以得到整句的翻译分数。希望求得翻译得分的 TOP k
&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/dijk.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/dijk.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Dijkstra&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Dijkstra&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回溯算法
&lt;ul&gt;
&lt;li&gt;穷举所有的排列组合情况，选取得分最高的前 k 个翻译结果&lt;/li&gt;
&lt;li&gt;时间复杂度为 O（mn），m 表示每个单词的平均可选翻译个数，n 表示单词数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dijkstra 算法
&lt;ul&gt;
&lt;li&gt;首先可以得到得分最高的一个组合，基于此组合来进行扩展，将每个单词的翻译分别替换成下一个得分最高的翻译。假设为 a0b0c0，扩展后为：a1b0c0、a0b1c0、a0b0c1&lt;/li&gt;
&lt;li&gt;每次从优先级队列（大顶堆）中取出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>数据结构（七）图的搜索</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2/</link>
        <pubDate>Wed, 23 Aug 2023 22:39:41 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2/</guid>
        <description>&lt;h2 id=&#34;应用背景&#34;&gt;应用背景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;广度、深度优先搜索，都是应用于图的搜索算法，是一种暴力搜索的算法。&lt;/li&gt;
&lt;li&gt;其他应用于图的搜索算法
&lt;ul&gt;
&lt;li&gt;A*&lt;/li&gt;
&lt;li&gt;IDA*&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;广度优先搜索-bfsbreadth-first-search&#34;&gt;广度优先搜索 BFS（Breadth First Search）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;主要目的：在图中寻找两个顶点间的路径&lt;/li&gt;
&lt;li&gt;思想：
&lt;ul&gt;
&lt;li&gt;类似于“地毯式搜索”，主要包含两个步骤
&lt;ul&gt;
&lt;li&gt;不断地访问顶点&lt;/li&gt;
&lt;li&gt;将“路径”记录下来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问顶点
&lt;ul&gt;
&lt;li&gt;将顶点的相邻顶点放入队列中，作为下一个需要访问的顶点。&lt;/li&gt;
&lt;li&gt;如果此顶点已经被访问过，则继续下一个访问下一个需要访问的顶点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记录“路径”
&lt;ul&gt;
&lt;li&gt;“路径”，即将每个顶点作为相邻顶点的“上一步”记录下来&lt;/li&gt;
&lt;li&gt;最终的路径为从终点开始，依次根据“上一步”找到起点&lt;/li&gt;
&lt;li&gt;当找到终点时停止访问顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码实现要点
&lt;ul&gt;
&lt;li&gt;visited 数组：记录顶点是否被访问&lt;/li&gt;
&lt;li&gt;queue 数组：记录需要被访问的顶点&lt;/li&gt;
&lt;li&gt;prev 数组：记录相邻顶点的“上一步”为访问顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复杂度分析
&lt;ul&gt;
&lt;li&gt;时间复杂度
&lt;ul&gt;
&lt;li&gt;每个顶点最多被访问一次，每个边也最多被访问一次&lt;/li&gt;
&lt;li&gt;O（V+E），V 为顶点的个数，E 为边的个数&lt;/li&gt;
&lt;li&gt;在连通图中，E 一定会大于等于 V - 1&lt;/li&gt;
&lt;li&gt;O（E）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间复杂度
&lt;ul&gt;
&lt;li&gt;使用邻接表记录顶点的相邻顶点&lt;/li&gt;
&lt;li&gt;O（V）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;深度优先搜索-dfsdepth-first-search&#34;&gt;深度优先搜索 DFS（Depth First Search）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;主要目的：在图中寻找两个顶点间的路径&lt;/li&gt;
&lt;li&gt;思想：
&lt;ul&gt;
&lt;li&gt;回漱思想，类似于“走迷宫”，当发现“无路可走”时，返回上一个“岔路口”，主要包含两个步骤
&lt;ul&gt;
&lt;li&gt;不断地访问顶点&lt;/li&gt;
&lt;li&gt;将“路径”记录下来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问顶点
&lt;ul&gt;
&lt;li&gt;不断地“深入”访问相邻顶点，直到顶点无相邻顶点或者顶点的相邻顶点已经被访问过&lt;/li&gt;
&lt;li&gt;当找到终点时停止访问顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记录“路径”
&lt;ul&gt;
&lt;li&gt;“路径”，即将每个顶点作为相邻顶点的“上一步”记录下来&lt;/li&gt;
&lt;li&gt;最终的路径为从终点开始，依次根据“上一步”找到起点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码实现要点
&lt;ul&gt;
&lt;li&gt;使用递归来实现&lt;/li&gt;
&lt;li&gt;visited 数组：记录顶点是否被访问&lt;/li&gt;
&lt;li&gt;prev 数组：记录相邻顶点的“上一步”为访问顶点&lt;/li&gt;
&lt;li&gt;found 布尔值：记录是否找到终点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复杂度分析
&lt;ul&gt;
&lt;li&gt;时间复杂度 O（E）
&lt;ul&gt;
&lt;li&gt;每个顶点最多被访问两次，每个边最多被访问两次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间复杂度 O（V）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;双向广度优先搜索&#34;&gt;双向广度优先搜索&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/two_way_bfs.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/two_way_bfs.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;双向广度优先搜索&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;双向广度优先搜索&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;求两个结点 a、b 的最短路径&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 a 出发，进行广度搜索，记录下 a 的所有一度结点 a1，查看 b 是否出现在集合 a1 中，如果有，则停止&lt;/li&gt;
&lt;li&gt;从 b 出发，进行广度搜索，记录下 b 的所有一度结点 b1，查看 a、a1 是否出现在 b 和 b1 的并集中&lt;/li&gt;
&lt;li&gt;重复上述两步，直到找到 a 和 b 的好友的交集 c，则 a、b 的最短通路长为 a 到 c 的通路长度 + b 到 c 的通路长度&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;启发式搜索算法heuristically-search-algorithm&#34;&gt;启发式搜索算法（Heuristically Search Algorithm）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;A* 搜索算法属于&lt;strong&gt;启发式搜索算法（Heuristically Search Algorithm）&lt;/strong&gt;，是对 Dijkstra 算法的优化和改造&lt;/li&gt;
&lt;li&gt;启发式搜索算法利用估价函数，避免“跑偏”，贪心地朝着最有可能到达终点的方向前进。&lt;strong&gt;启发式搜索算法找出的路径不一定是最短路径，但可以更加快速地找到最短路线&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;a-搜索算法-a-star-search-algorithm&#34;&gt;A* 搜索算法 A Star Search Algorithm&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;遍历顶点时，从起点到这个顶点的路径及路径的长度是确定的，记作 g（i），i 表示顶点编号&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;启发函数（Heuristic Function）&lt;/strong&gt;，即使用一个估算值来判断从这个顶点到终点的路径长度，避免“跑偏”，记作 h（i）
&lt;ul&gt;
&lt;li&gt;可以使用这个顶点到终点之间的直线距离，即欧几里得距离，近似地估计路径长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;欧几里得距离涉及到比较耗时的开根号计算，可以使用更加简洁的曼哈顿距离（Manhattan Distance），只有简单的加减计算&lt;/li&gt;
&lt;li&gt;使用估价函数（Evaluation Function），来综合判断该优先遍历哪个顶点，记作 f（i）。譬如 f（i）= g（i）+ h（i）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;a-搜索算法和-dijkstra-算法的区别&#34;&gt;A* 搜索算法和 Dijkstra 算法的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;优先级队列构建的方式不同
&lt;ul&gt;
&lt;li&gt;A* 搜索算法是根据估价函数（f（i））来构建优先级队列&lt;/li&gt;
&lt;li&gt;Dijkstra 算法是根据从起点到当前顶点的路径长度（g（i））来构建优先级队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A* 搜索算法在更新顶点的路径长度（g（i））时，也会同步更新估价函数的值（f（i））&lt;/li&gt;
&lt;li&gt;循环结束的条件不同
&lt;ul&gt;
&lt;li&gt;A* 搜索算法遍历到终点时就结束&lt;/li&gt;
&lt;li&gt;Dijkstra 算法在终点出优先级队列时结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A* 搜索算法找到的路径不是最短路径，Dijkstra 算法找到的路径是最短路径&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>数据结构（六）图</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E5%9B%BE/</link>
        <pubDate>Wed, 23 Aug 2023 22:33:41 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD%E5%9B%BE/</guid>
        <description>&lt;h2 id=&#34;图-graph-相关概念&#34;&gt;图 Graph 相关概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;顶点 Vertex：图中的元素&lt;/li&gt;
&lt;li&gt;边 Edge：图中的一个顶点与任意其他顶点建立的连接关系&lt;/li&gt;
&lt;li&gt;度 Degree：与顶点相连接的边的条数&lt;/li&gt;
&lt;li&gt;入度 In-degree：顶点的入度，表示有多少条边指向这个顶点&lt;/li&gt;
&lt;li&gt;出度 Out-degree：顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点&lt;/li&gt;
&lt;li&gt;有向图：图中的边带有方向&lt;/li&gt;
&lt;li&gt;无向图：图中的边不带有方向&lt;/li&gt;
&lt;li&gt;带权图：图中的每条边都有一个权重 weight&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;图的存储方式&#34;&gt;图的存储方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;邻接矩阵 Adjacency Matrix&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/adj_matrix.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/adj_matrix.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;邻接矩阵&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;邻接矩阵&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用二维数组来存储&lt;/li&gt;
&lt;li&gt;无向图 A
&lt;ul&gt;
&lt;li&gt;如果顶点 i 与顶点 j 之间有边，就将 A[i][j] 和 A[j][i] 标记为1&lt;/li&gt;
&lt;li&gt;其余标记为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有向图 A
&lt;ul&gt;
&lt;li&gt;如果顶点 i 与顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，就将 A[i][j] 标记为 1&lt;/li&gt;
&lt;li&gt;其余标记为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;带权图
&lt;ul&gt;
&lt;li&gt;在数组中存储相应的权重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;简单直观&lt;/li&gt;
&lt;li&gt;获取顶点的关系时，非常的高效&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;方便计算，可以将很多图的运算转换成矩阵之间的运算&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：比较浪费存储空间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邻接表 Adjacency List&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/adj_list.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/adj_list.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;邻接表&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;邻接表&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点&lt;/li&gt;
&lt;li&gt;链表的存储方式对缓存不太友好，可以将链表替换成其他更加高效的数据结构，如平衡二叉查找树、跳表、有序动态数组等&lt;/li&gt;
&lt;li&gt;优点：比较节省存储空间&lt;/li&gt;
&lt;li&gt;缺点：链表无法支持快速查找，可以使用跳表、红黑树、有序动态数组、散列表代替链表&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图的应用&#34;&gt;图的应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;社交网络的好友关系&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用一个邻接表来存储好友关系的有向图，可以快速查找到某个用户关注了哪些用户，即此用户的关注列表&lt;/li&gt;
&lt;li&gt;使用一个逆邻接表来存储好友关系，可以快速查找某个用户被哪些用户关注，即此用户的粉丝列表&lt;/li&gt;
&lt;li&gt;使用链表的邻接表不能快速地判断两个用户之间的好友关系，可以将链表改为红黑树、跳表、有序动态数组、散列表中的一种&lt;/li&gt;
&lt;li&gt;若是需要按照用户名称的首字母排序，分也来获取用户的粉丝列表或关注列表，则适合使用跳表。跳表的插入、删除、查找的时间复杂度为 O（logn），空间复杂度为 O（n），跳表本身的数据也是有序的。&lt;/li&gt;
&lt;li&gt;如果数据太多，可以使用哈希算法等数据分片的方法，将邻接表存储在不同的机器上。或者利用外部存储，即数据库。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构（五）树 — B&#43;树</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%A0%91-b-%E6%A0%91/</link>
        <pubDate>Wed, 23 Aug 2023 22:25:43 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%A0%91-b-%E6%A0%91/</guid>
        <description>&lt;h2 id=&#34;树-tree-相关概念&#34;&gt;树 Tree 相关概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;父节点、子节点、兄弟节点、根节点、叶子节点（叶节点）&lt;/li&gt;
&lt;li&gt;节点的高度（Height）
&lt;ul&gt;
&lt;li&gt;节点到叶子节点的最长路径（边数），从最底层开始计数，计数的起点是 0&lt;/li&gt;
&lt;li&gt;树的高度 = 根节点的高度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点的深度（Depth）
&lt;ul&gt;
&lt;li&gt;根节点到当前节点所经历的边的个数，从根节点开始度量，计数起点是 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点的层数（Level）
&lt;ul&gt;
&lt;li&gt;节点的深度 + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;b-树-b-tree&#34;&gt;B+ 树 B+ Tree&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;B+ 树 是通过 B 树（二叉查找树）演化而来，目的是在二叉查找树中能够按照区间来查找数据&lt;/li&gt;
&lt;li&gt;B+ 树中的非叶子节点不存储数据，&lt;strong&gt;只存储索引&lt;/strong&gt;，而 B 树中的节点存储数据&lt;/li&gt;
&lt;li&gt;B+ 树中的叶子节点使用链表串联起来，链表中的数据是有序的，可以按区间查找，而 B 树中的叶子节点不需要链表串联&lt;/li&gt;
&lt;li&gt;B+ 树的根节点一般放在内存中，其他节点存储在磁盘中&lt;/li&gt;
&lt;li&gt;B+ 树中的每个节点中子节点的个数不能超过 m 个，即 m叉树，也不能小于 m/2（除根节点外）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;b-树的实现&#34;&gt;B+ 树的实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;B+ 树的非叶子节点存储索引，存储在磁盘中
&lt;ul&gt;
&lt;li&gt;内存的访问速度是纳米级别的，磁盘的访问速度是毫秒级别的，读取同样大小的数据，从磁盘中读取花费的时间是从内存中读取的上万倍，甚至几十万倍&lt;/li&gt;
&lt;li&gt;每个节点的读取操作，都对应一次磁盘 IO 操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的高度 = 每次查询数据时磁盘 IO 操作的最大次数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;尽量减少磁盘 IO 操作，也就是尽量降低树的高度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B+ 树的叶子节点存储的是 k 个数据行的键值、地址信息、当前节点在链表中的前驱节点的地址、当前节点在链表中的后继节点的地址，k 的取值由事先计算得到&lt;/li&gt;
&lt;li&gt;B+ 树是一个 m 叉树，m 的取值由事先计算得到&lt;/li&gt;
&lt;li&gt;k、m 的计算方式
&lt;ul&gt;
&lt;li&gt;操作系统按照页（PAGE_SIZE）的方式读取内存、磁盘中的数据，一页的大小通常为 4KB，可以通过 getconf PAGE_SIZE 命令查看&lt;/li&gt;
&lt;li&gt;当读取的数据量超过一页时，会触发多次 IO 操作&lt;/li&gt;
&lt;li&gt;k、m 的取值则根据每个节点的大小 &amp;lt;= 页的大小，且尽可能的大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;b-树的操作&#34;&gt;B+ 树的操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照主键的值在树中进行查找，当查找到叶子节点后
&lt;ul&gt;
&lt;li&gt;若查找主键 ，则根据叶子节点中的地址信息，获取到具体数据&lt;/li&gt;
&lt;li&gt;若查找范围区间，则在链表中继续查找，直到不满足条件（达到 limit 限制、超过范围区间），获取到符合区间值的所有数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+ 树中，m 值是由事先计算得出，即每个节点最多只能有 m 个子节点&lt;/li&gt;
&lt;li&gt;当插入数据时同时更新索引，插入后的节点个数超过 m 个，则需要对索引进行更新分裂操作&lt;/li&gt;
&lt;li&gt;将当前节点分裂成两个节点，若当前节点分裂之后，父节点的子节点个数超过 m 个，则继续向上分裂，直至父节点的子节点个数 &amp;lt; m&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/b&amp;#43;_tree.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/b&amp;#43;_tree.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;b&amp;#43;树&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;b+树&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除某个数据同时删除索引，当删除后的节点个数小于 m/2 时，则需要对索引进行更新合并操作&lt;/li&gt;
&lt;li&gt;当前节点的个数小于 m/2，将当前节点和它相邻的兄弟节点合并&lt;/li&gt;
&lt;li&gt;若合并之后的节点个数超过 m，则执行插入的“分裂”操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/b&amp;#43;_tree_2.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/b&amp;#43;_tree_2.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;b&amp;#43;树&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;b+树&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>数据结构（四）树 — 红黑树、堆</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%A0%86/</link>
        <pubDate>Wed, 23 Aug 2023 22:22:42 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%A0%86/</guid>
        <description>&lt;h2 id=&#34;树-tree-相关概念&#34;&gt;树 Tree 相关概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;父节点、子节点、兄弟节点、根节点、叶子节点（叶节点）&lt;/li&gt;
&lt;li&gt;节点的高度（Height）
&lt;ul&gt;
&lt;li&gt;节点到叶子节点的最长路径（边数），从最底层开始计数，计数的起点是 0&lt;/li&gt;
&lt;li&gt;树的高度 = 根节点的高度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点的深度（Depth）
&lt;ul&gt;
&lt;li&gt;根节点到当前节点所经历的边的个数，从根节点开始度量，计数起点是 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点的层数（Level）
&lt;ul&gt;
&lt;li&gt;节点的深度 + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;平衡二叉查找树&#34;&gt;平衡二叉查找树&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义：二叉树中任意一个节点的左右子树的高度相差不能大于 1。&lt;/li&gt;
&lt;li&gt;目的：解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。&lt;/li&gt;
&lt;li&gt;常见的平衡二叉查找树，AVL 树、Splay Tree（伸展树）、Treap（树堆）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;红黑树-red-black-tree&#34;&gt;红黑树 Red-Black Tree&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;简称 R-B Tree，是一种不严格的平衡二叉查找树。&lt;strong&gt;是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;红黑树的高度近似 log2n，是近似平衡，插入、删除、查找操作的时间复杂度都是 O（logn）。&lt;/li&gt;
&lt;li&gt;在红黑树中的节点，一类被标记为黑色，一类被标记为红色。&lt;/li&gt;
&lt;li&gt;红黑树的要求
&lt;ul&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据（为了简化红黑树的代码实现）&lt;/li&gt;
&lt;li&gt;任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的&lt;/li&gt;
&lt;li&gt;每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用红黑树的高度是否比较稳定地趋近 log2n 来证明红黑树是否是近似平衡的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;左旋rotate-left右旋rotate-right&#34;&gt;左旋（rotate left）、右旋（rotate right）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;左旋 rotate left，围绕某个节点的左旋&lt;/li&gt;
&lt;li&gt;右旋 rotate right，围绕某个节点的右旋&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;红黑树的实现&#34;&gt;红黑树的实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;插入操作
&lt;ul&gt;
&lt;li&gt;插入的节点必须是红色的，新插入的节点都是放在叶子节点上&lt;/li&gt;
&lt;li&gt;如果插入节点的父节点是黑色的，不需要做其他操作&lt;/li&gt;
&lt;li&gt;如果插入节点是根节点，直接将节点的颜色置为黑色&lt;/li&gt;
&lt;li&gt;其他情况则需要进入红黑树的平衡调整过程
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_1.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_1.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 1&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 1&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色&lt;/li&gt;
&lt;li&gt;将关注节点 a 的祖父节点 c 的颜色设置成红色&lt;/li&gt;
&lt;li&gt;关注节点变成 a 的祖父节点 c&lt;/li&gt;
&lt;li&gt;跳到 CASE 2 或 CASE 3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点是其父节点 b 的右子节点&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_2.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_2.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 2&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 2&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关注节点变成节点 a 的父节点 b&lt;/li&gt;
&lt;li&gt;围绕新的关注节点 b 左旋&lt;/li&gt;
&lt;li&gt;跳到 CASE 3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_3.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_3.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 3&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 3&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;围绕关注节点 a 的祖父节点 c 右旋&lt;/li&gt;
&lt;li&gt;将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除操作
&lt;ul&gt;
&lt;li&gt;针对删除节点的初步调整
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CASE 1：如果要删除的节点是 a，它只有一个子节点 b&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_4.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_4.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 1&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 1&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除节点 a，并且把节点 b 替换道节点 a 的位置&lt;/li&gt;
&lt;li&gt;节点 a 只能是黑色，节点 b 也只能是红色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_5.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_5.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 2&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 2&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果节点 a 的后继节点就是右子节点 c，那么右子节点 c 肯定没有左子树。将节点 a 删除，并且将节点 c 替换到节点 a 的位置&lt;/li&gt;
&lt;li&gt;把节点 c 的颜色设置为跟节点 a 相同的颜色&lt;/li&gt;
&lt;li&gt;如果节点 c 是黑色，将节点 c 的右子节点 d 多加一个黑色&lt;/li&gt;
&lt;li&gt;将关注节点变成节点 d&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右节点&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_6.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_6.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 3&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 3&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1&lt;/li&gt;
&lt;li&gt;将节点 a 替换成后继节点 d&lt;/li&gt;
&lt;li&gt;把节点 d 的颜色设置为跟节点 a 相同的颜色&lt;/li&gt;
&lt;li&gt;如果节点 d 是黑色，将节点 d 的右子节点 c 多加一个黑色&lt;/li&gt;
&lt;li&gt;关注节点变成节点 c&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;针对关注节点进行二次调整，为了让红黑树中不存在相邻的红色节点
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_7.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_7.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 1&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 1&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;围绕关注节点 a 的父节点 b 左旋&lt;/li&gt;
&lt;li&gt;关注节点 a 的父节点 b 和祖父节点 c 交换颜色&lt;/li&gt;
&lt;li&gt;关注节点不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_8.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_8.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 2&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 2&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将关注节点 a 的兄弟节点 c 的颜色变成红色&lt;/li&gt;
&lt;li&gt;从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或黑色&lt;/li&gt;
&lt;li&gt;给关注节点 a 的父节点 b 添加一个黑色节点&lt;/li&gt;
&lt;li&gt;关注节点从 a 变成其父节点 b&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_9.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_9.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 3&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 3&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;围绕关注节点 a 的兄弟节点 c 右旋&lt;/li&gt;
&lt;li&gt;节点 c 和节点 d 交换颜色&lt;/li&gt;
&lt;li&gt;关注节点不变&lt;/li&gt;
&lt;li&gt;跳转到 CASE 4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_10.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/rb_tree_case_10.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;case 4&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;case 4&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;围绕关注节点 a 的父节点 b 左旋&lt;/li&gt;
&lt;li&gt;将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色&lt;/li&gt;
&lt;li&gt;将关注节点 a 的父节点 b 的颜色设置为黑色&lt;/li&gt;
&lt;li&gt;从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色&lt;/li&gt;
&lt;li&gt;将关注节点 a 的叔叔节点 e 设置为黑色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/fei33423/article/details/79132930&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/fei33423/article/details/79132930&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/abcdef314159/article/details/77193888&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/abcdef314159/article/details/77193888&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;堆-heap&#34;&gt;堆 Heap&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;堆是一种特殊的树，是一个完全二叉树&lt;/li&gt;
&lt;li&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值，大顶堆、小顶堆&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;堆的实现&#34;&gt;堆的实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;堆是一个完全二叉树，使用数组来存储，节省存储空间。直接通过数组的下标，找到对应节点的左右子节点和父节点&lt;/li&gt;
&lt;li&gt;堆的操作
&lt;ul&gt;
&lt;li&gt;插入元素（堆化），时间复杂度 O（logn）
&lt;ul&gt;
&lt;li&gt;从下往上的堆化，遇到不满足大小条件的就交换父子节点&lt;/li&gt;
&lt;li&gt;从上往下的堆化，遇到不满足大小条件的就交换父子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除堆顶元素
&lt;ul&gt;
&lt;li&gt;从上往下的堆化，时间复杂度 O（logn）
&lt;ul&gt;
&lt;li&gt;将最后一个数字放在堆顶，遇到不满足大小条件的就交换父子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基于堆实现排序&#34;&gt;基于堆实现排序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;建堆，时间复杂度，O（n）
&lt;ul&gt;
&lt;li&gt;将数组原地建成一个堆，直接在原数组上操作&lt;/li&gt;
&lt;li&gt;方式
&lt;ul&gt;
&lt;li&gt;从前往后处理数组数据，从下往上的堆化。不断地在堆中插入元素，对堆进行插入操作&lt;/li&gt;
&lt;li&gt;从后往前处理数组数据，从上往下的堆化。从非叶子节点开始，依次堆化。
&lt;ol&gt;
&lt;li&gt;对于完全二叉树来说，下标从 n/2 + 1 到 n 的都是叶子节点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序，时间复杂度，O（nlogn）
&lt;ul&gt;
&lt;li&gt;堆顶（数组中的第一个元素）就是最大的元素&lt;/li&gt;
&lt;li&gt;删除堆顶元素，将堆顶和最后一个元素交换，最大元素放在下标为 n 的位置&lt;/li&gt;
&lt;li&gt;将剩下的 n - 1 个元素重新构建成堆&lt;/li&gt;
&lt;li&gt;重复上述操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆排序整体的时间复杂度是O（nlogn），不是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;为什么快速排序比堆排序性能好时间复杂度同样为onlogn&#34;&gt;为什么快速排序比堆排序性能好（时间复杂度同样为O(nlogn)）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;堆排序数据访问的方式没有快速排序友好
&lt;ul&gt;
&lt;li&gt;快速排序的数据是顺序访问的，而堆排序是跳着访问的，对 CPU 缓存不友好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;堆的应用&#34;&gt;堆的应用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;求 topK&lt;/li&gt;
&lt;li&gt;流里面的中值&lt;/li&gt;
&lt;li&gt;流里面的中位数&lt;/li&gt;
&lt;li&gt;优先级队列&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;优先级队列&#34;&gt;优先级队列&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;思路：数据的出队顺序按照优先级高的先出队&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;一个堆就可以看作是一个优先级队列&lt;/li&gt;
&lt;li&gt;在优先级队列中，执行入队操作，就相当于往堆中插入一个元素。执行出队操作，相当于取出堆顶元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;合并有序小文件&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;假设有 100 个小文件，每个文件的大小是 100 MB，每个文件中存储的都是有序的字符串。将这 100 个小文件合并成一个大文件&lt;/li&gt;
&lt;li&gt;使用数组的实现
&lt;ul&gt;
&lt;li&gt;从这 100 个文件中，各取第一个字符串，放入数组中，比较大小，把最小的字符串放入合并后的大文件中，并将它从数组中删除。&lt;/li&gt;
&lt;li&gt;假设这个最小的字符串来自 13.txt，就从这个文件中取下一个字符串，放入数组中。重新比较大小，选择最小的放入合并后的大文件，将它从数组中删除。&lt;/li&gt;
&lt;li&gt;重复上述步骤，直至所有文件中的数据都放入到大文件为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用优先队列的实现
&lt;ul&gt;
&lt;li&gt;和使用数组的方法类似，只不过将从文件中取出的字符串放在小顶堆中。&lt;/li&gt;
&lt;li&gt;删除堆顶元素，即最小的元素。然后再从堆顶元素所在的文件当中取出下一个字符串，放入堆中。&lt;/li&gt;
&lt;li&gt;重复上述步骤，直至所有文件中的数据都放入到大文件为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高性能定时器&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;假设定时器中维护了很多定时任务，每个任务都设定了一个要出发执行的时间点。&lt;/li&gt;
&lt;li&gt;简单粗暴的实现
&lt;ul&gt;
&lt;li&gt;每隔一个很小的单位时间（如 1 秒）扫描一遍任务列表，检查是否有任务达到设定的执行时间。如果达到了，就执行任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用堆的实现
&lt;ul&gt;
&lt;li&gt;按照任务设定的执行时间，将这些任务存储在优先队列中，队列首部（小顶堆的堆顶）存储的是最先执行的任务。&lt;/li&gt;
&lt;li&gt;将队列首部任务的执行时间与当前时间相减，得到时间间隔 T。即从当前开始，第一个任务执行需要等待的时间。&lt;/li&gt;
&lt;li&gt;时间 T 过去后，定时器取优先级队列中队列首部的执行任务。&lt;/li&gt;
&lt;li&gt;移除队列首部任务，然后再计算新的队列首部任务的执行时间点与当前时间点的差值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;求-top-k&#34;&gt;求 Top K&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;静态数据集合
&lt;ul&gt;
&lt;li&gt;例：如何在包含 n 个数据的数组中，查找前 K 大的数据&lt;/li&gt;
&lt;li&gt;使用小顶堆，维护一个大小为 K 的小顶堆&lt;/li&gt;
&lt;li&gt;实现：顺序遍历数组，从数组中取出数据与堆顶元素比较，如果比堆顶元素大，则把堆顶元素删除，并将这个数据插入到堆中。如果比堆顶元素小，则不做任何处理，继续遍历数组。&lt;/li&gt;
&lt;li&gt;时间复杂度
&lt;ul&gt;
&lt;li&gt;遍历数组：O（n）&lt;/li&gt;
&lt;li&gt;堆化：O（logK）&lt;/li&gt;
&lt;li&gt;所以总共是 O（nlogK）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态数据集合
&lt;ul&gt;
&lt;li&gt;例：数据集合有两个操作，一个是添加数据，一个是查询当前 K 大数据&lt;/li&gt;
&lt;li&gt;一直维护一个 K 大小的小顶堆&lt;/li&gt;
&lt;li&gt;实现：当有数据被添加到集合中时，与堆顶元素比较大小。如果比堆顶元素大，则把堆顶元素删除，并将这个元素插入堆中。如果比堆顶元素小，则不做处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;利用堆求中位数&#34;&gt;利用堆求中位数&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;静态数据集合
&lt;ul&gt;
&lt;li&gt;先排序，取下标 n / 2 的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态数据集合
&lt;ul&gt;
&lt;li&gt;维护两个堆，一个大顶堆，一个小顶堆&lt;/li&gt;
&lt;li&gt;大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据&lt;/li&gt;
&lt;li&gt;中位数就是大顶堆的堆顶元素&lt;/li&gt;
&lt;li&gt;实现：
&lt;ul&gt;
&lt;li&gt;n 个数据，如果 n 是偶数，按照从小到大排序，前 n / 2 个数据存储在大顶堆中，后 n / 2 个数据存储在小顶堆中。如果 n 是奇数，大顶堆存储 n / 2 + 1 个数据，小顶堆中存储 n / 2 个数据&lt;/li&gt;
&lt;li&gt;如果新加入的数据小于等于大顶堆的堆顶元素，将这个数据插入到大顶堆，否则，将这个数据插入到小顶堆&lt;/li&gt;
&lt;li&gt;当不满足大顶堆和小顶堆的数据个数时，通过将一个堆中不停地将堆顶元素移动到另一个堆，来满足数据个数的要求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延伸：如何快速求 n% 的数据，例：如何快速求接口的 99% 响应时间&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;使用两个堆，一个大顶堆，一个小顶堆。大顶堆中保存前 n% 的数据，小顶堆中保存 1 - n% 的数据。大顶堆堆顶的数据就是要求的数据。&lt;/li&gt;
&lt;li&gt;每次插入一个数据的时候，判断这个数据跟大顶堆堆顶数据和小顶堆堆顶数据的大小关系。如果新插入的数据比大顶堆的堆顶数据小，则插入大顶堆。如果新插入的数据比小顶堆的堆顶数据大，则插入小顶堆。&lt;/li&gt;
&lt;li&gt;每次插入数据后，需要重新计算大顶堆和小顶堆的数据格式，看看是否还满足要求。如果不满足，就将一个堆中的数据移动到另一个堆中，直到满足要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>数据结构（三）树 — 二叉树、递归树</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E6%A0%91/</link>
        <pubDate>Wed, 23 Aug 2023 22:19:41 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E6%A0%91/</guid>
        <description>&lt;h2 id=&#34;树-tree-相关概念&#34;&gt;树 Tree 相关概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;父节点、子节点、兄弟节点、根节点、叶子节点（叶节点）&lt;/li&gt;
&lt;li&gt;节点的高度（Height）
&lt;ul&gt;
&lt;li&gt;节点到叶子节点的最长路径（边数），从最底层开始计数，计数的起点是 0&lt;/li&gt;
&lt;li&gt;树的高度 = 根节点的高度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点的深度（Depth）
&lt;ul&gt;
&lt;li&gt;根节点到当前节点所经历的边的个数，从根节点开始度量，计数起点是 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点的层数（Level）
&lt;ul&gt;
&lt;li&gt;节点的深度 + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二叉树-binary-tree&#34;&gt;二叉树 Binary Tree&lt;/h2&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;每个节点最多有两个子节点，分别是左子节点和右子节点&lt;/li&gt;
&lt;li&gt;满二叉树
&lt;ul&gt;
&lt;li&gt;叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点&lt;/li&gt;
&lt;li&gt;满二叉树的高度大约是 log2(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完全二叉树
&lt;ul&gt;
&lt;li&gt;叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大&lt;/li&gt;
&lt;li&gt;完全二叉树的高度是 log2(n) 向下取整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储二叉树
&lt;ul&gt;
&lt;li&gt;基于指针或引用的二叉链式存储法
&lt;ul&gt;
&lt;li&gt;每个节点有三个字段，分别存储数据、左右子节点的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于数组的顺序存储法
&lt;ul&gt;
&lt;li&gt;根节点存储在下标为 1 的位置&lt;/li&gt;
&lt;li&gt;若节点存储在数组中下标为 i 的位置，左子节点存储在下标 2 * i 的位置，右子节点存储在下标 2 * i + 1 的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历二叉树
&lt;ul&gt;
&lt;li&gt;前序遍历
&lt;ul&gt;
&lt;li&gt;对于树中的任意节点，先打印这个节点，再打印它的左子树，最后打印它的右子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中序遍历
&lt;ul&gt;
&lt;li&gt;对于树中的任意节点，先打印它的左子树，再打印它本身，最后打印它的右子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后序遍历
&lt;ul&gt;
&lt;li&gt;对于树中的任意节点，先打印它的左子树，再打印它的右子树，最后打印它本身&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;递归公式
&lt;ul&gt;
&lt;li&gt;前序遍历的递推公式：preOrder(r) = print r-&amp;gt;preOrder(r-&amp;gt;left)-&amp;gt;preOrder(r-&amp;gt;right)&lt;/li&gt;
&lt;li&gt;中序遍历的递推公式：inOrder(r) = inOrder(r-&amp;gt;left)-&amp;gt;print r-&amp;gt;inOrder(r-&amp;gt;right)&lt;/li&gt;
&lt;li&gt;后序遍历的递推公式：postOrder(r) = postOrder(r-&amp;gt;left)-&amp;gt;postOrder(r-&amp;gt;right)-&amp;gt;print r&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉查找树--二叉搜索树binary-search-tree&#34;&gt;二叉查找树 / 二叉搜索树（Binary Search Tree）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;前提是一颗&lt;strong&gt;完全二叉树&lt;/strong&gt; ，在树中的任意一个节点，其左子树中的每个节点的值，都小于这个节点的值，而右子树节点的值都大于这个节点的值&lt;/li&gt;
&lt;li&gt;查找操作
&lt;ul&gt;
&lt;li&gt;先取根节点，如果等于要查找的数据，则返回，若查找的数据比根节点的值小，则在左子树中递归查找，若查找的数据比根节点的值大，则在右子树中递归查找&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;插入操作
&lt;ul&gt;
&lt;li&gt;如果要插入的数据比节点的数据大
&lt;ul&gt;
&lt;li&gt;节点的右子树为空，直接将新数据插入到右子节点的位置&lt;/li&gt;
&lt;li&gt;节点的右子树不为空，继续递归遍历右子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果要插入的数据比节点的数据小
&lt;ul&gt;
&lt;li&gt;节点的左子树为空，直接将新数据插入到左子节点的位置&lt;/li&gt;
&lt;li&gt;节点的左子树不为空，继续递归遍历左子树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除操作
&lt;ul&gt;
&lt;li&gt;如果要删除的节点没有子节点
&lt;ul&gt;
&lt;li&gt;直接将父节点中指向要删除节点的指针置为 null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果要删除的节点只有一个子节点（左子节点或右子节点）
&lt;ul&gt;
&lt;li&gt;更新父节点中指向要删除节点的指针，让它指向要删除节点的子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果要删除的节点有两个子节点
&lt;ul&gt;
&lt;li&gt;找到这个节点的右子树中的最小节点，替换到要删除的节点上，删除这个最小节点&lt;/li&gt;
&lt;li&gt;或者找到这个节点的左子树中的最大节点，替换到要删除的节点上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;取巧的删除操作
&lt;ul&gt;
&lt;li&gt;单纯地将要删除的节点标记为“已删除”，没有真正地从树中将这个节点去掉，比较浪费内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速地查找最大节点和最小节点、前驱节点和后继节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度跟树的高度成正比，也就是 O(height)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;支持重复数据的二叉查找树&#34;&gt;支持重复数据的二叉查找树&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;二叉查找树中的每个节点不仅仅存储一个数据，通过链表和支持动态扩容的数据等数据结构，把值相同的数据都存储在同一个节点上&lt;/li&gt;
&lt;li&gt;二叉查找树中的每个节点只存储一个数据，插入相同值时，将要插入的数据放到这个节点的右子树，把这个新插入的数据当作是大于这个节点的值来处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二叉查找树的优势与散列表相比&#34;&gt;二叉查找树的优势（与散列表相比）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;散列表中的数据是无序存储的，而二叉查找树的中序遍历可以在 O（n）的时间复杂度内，输入有序的数据&lt;/li&gt;
&lt;li&gt;散列表扩容耗时多，而且遇到散列冲突时性能不稳定，平衡二叉查找树的性能稳定，时间复杂度为 O（logn）&lt;/li&gt;
&lt;li&gt;由于哈希冲突，散列表的查找速度不一定比平衡二叉查找树的效率高&lt;/li&gt;
&lt;li&gt;散列表的构造复杂，需要考虑到散列函数的设计、冲突解决办法、扩容、缩容等，而平衡二叉查找树只需要考虑平衡性的问题&lt;/li&gt;
&lt;li&gt;为了避免过多的散列冲突，散列表装载因子不能过大，会浪费一定的存储空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;递归树&#34;&gt;递归树&lt;/h2&gt;
&lt;p&gt;递归的思想是，&lt;strong&gt;将大问题分解为小问题来求解&lt;/strong&gt;，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。如果把这个一层一层的分解过程画成图，它其实就是一棵树，这棵树就是递归树。&lt;/p&gt;
&lt;h3 id=&#34;借助递归树分析递归算法的时间复杂度&#34;&gt;借助递归树分析递归算法的时间复杂度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分析快速排序的时间复杂度&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/quick_sort_tree.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/quick_sort_tree.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;快排递归树&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;快排递归树&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设每次分区后，两个分区的大小比例为 1 ： k，递推公式可以写成 T（n）= T（n / 10）+ T（9n / 10）&lt;/li&gt;
&lt;li&gt;每层分区操作所遍历的个数之和是 n（固定）&lt;/li&gt;
&lt;li&gt;当分区不能均匀的一分为二时，递归树不是满二叉树，那么递归树的高度介于最短路径（每次都是 1 / 10）和最长路径（每次都是 9 / 10）之间，所以时间复杂度介于
nlog10（n）和 nlog9/10（n）之间，时间复杂度仍然是 O（nlog（n））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析斐波那契数列的时间复杂度&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/tree_fn.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/tree_fn.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;斐波那契数列&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;斐波那契数列&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;f（n） = f（n - 1） + f（n - 2），每次数据规模都是 -1 或者 -2，叶子结点的数据规模是 1 或者 2。&lt;/li&gt;
&lt;li&gt;最长路径是 n（每次走 1 的数据），最短路径是 n / 2（每次走 2 的数据）&lt;/li&gt;
&lt;li&gt;合并操作需要一次加法运算，第一层的时间消耗是 1，第二层是 2，第三层是 4。如果是最长路径，则总时间消耗是 1 + 2 + 4 + &amp;hellip; + 2n + 1。如果是最短路径，则总消耗时间是 1 + 2 + &amp;hellip; + 2n/2 + 1。&lt;/li&gt;
&lt;li&gt;时间复杂度介于 O（2n）和 O（2n/2）之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析全排列的时间复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把 n 个数据的所有排列都找出来，如果确定了最后一位数据，就变成了求解剩下 n - 1 个数据的排列问题。所以 n 个数据的排列问题，可以分解成 n 个 n - 1 个数据的排列的子问题。&lt;/li&gt;
&lt;li&gt;f(1,2,&amp;hellip;n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +&amp;hellip;+{最后一位是n, f(n-1)}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构（二）线性表 — 栈、队列</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%A0%88%E9%98%9F%E5%88%97/</link>
        <pubDate>Wed, 23 Aug 2023 22:12:18 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%A0%88%E9%98%9F%E5%88%97/</guid>
        <description>&lt;h2 id=&#34;线性表&#34;&gt;线性表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;每个线性表上的数据最多只有前和后两个方向，如 数组、链表、队列、栈 等&lt;/li&gt;
&lt;li&gt;非线性表，数据之间不是简单的前后关系，如 二叉树、堆、图 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈-stack&#34;&gt;栈 Stack&lt;/h2&gt;
&lt;h3 id=&#34;栈数据结构的特点&#34;&gt;“栈”数据结构的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;后进者先出，先进者后出（类似一堆盘子）&lt;/li&gt;
&lt;li&gt;是一种“操作受限”的线性表（只有 入栈 push、出栈 pop 的操作）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;栈的实现空间复杂度-o1&#34;&gt;栈的实现，空间复杂度 O（1）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;顺序栈，用数组实现的栈
&lt;ul&gt;
&lt;li&gt;出栈操作，时间复杂度 O（1）&lt;/li&gt;
&lt;li&gt;入栈操作，最好情况时间复杂度O（1），最差情况时间复杂度 O（n），均摊时间复杂度 O（1）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链式栈，用链表实现的栈
&lt;ul&gt;
&lt;li&gt;出栈、入栈操作，时间复杂度 O（1）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;栈的实际应用&#34;&gt;栈的实际应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;函数调用栈
&lt;ol&gt;
&lt;li&gt;操作系统给每个线程分配一块独立的内存空间，以栈的结构来存储函数调用时的临时变量&lt;/li&gt;
&lt;li&gt;每进入一个函数，将临时变量作为一个栈帧入栈，当被调用函数执行完成后，将这个函数对应的栈帧出栈&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;表达式求值
&lt;ol&gt;
&lt;li&gt;使用两个栈来分别保存，操作数和运算符&lt;/li&gt;
&lt;li&gt;从左向右遍历表达式，当遇到数字时，直接压入操作数栈，遇到运算符时，与运算符的栈顶元素进行比较&lt;/li&gt;
&lt;li&gt;当运算符栈顶的运算符优先级高时，将当前运算符压入栈，当运算符栈顶的运算符优先级低或相同时，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，进行计算，并将计算后的结果压入操作数栈&lt;/li&gt;
&lt;li&gt;持续比较，直到结束&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;检验括号匹配
&lt;ol&gt;
&lt;li&gt;从左到右依次扫描字符串，用栈保存未匹配的括号（如，( [ { 等）&lt;/li&gt;
&lt;li&gt;当扫描到需要匹配的括号（如，) ] } 等），则从栈顶取出一个括号，若匹配，则继续，若不匹配，则说明为非法格式&lt;/li&gt;
&lt;li&gt;当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式，否则，说明有未匹配的括号，则为非法格式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;浏览器的前进后退功能
&lt;ol&gt;
&lt;li&gt;使用两个栈 X Y
&lt;ul&gt;
&lt;li&gt;把首次浏览的页面一次压入栈 X&lt;/li&gt;
&lt;li&gt;点击后退时，依次从栈 X 中出栈，并将出栈的数据放入栈 Y，若栈 X 为空，则说明无法后退&lt;/li&gt;
&lt;li&gt;点击前进时，依次从栈 Y 中出栈，并将出栈的数据放入栈 X，若栈 Y 为空，则说明无法前进&lt;/li&gt;
&lt;li&gt;当跳转到新的页面时，则需要清空栈 Y&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用双向链表，使用 prev 和 next 来跳转&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存中的堆栈&#34;&gt;内存中的堆栈&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;内存中的堆栈和数据结构中的堆栈不是一个概念，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构&lt;/li&gt;
&lt;li&gt;内存空间在逻辑上分为三部分：代码区，数据静态区和动态数据区，动态数据区分为 栈区 和 堆区&lt;/li&gt;
&lt;li&gt;代码区：存储方法体的二进制代码，高级调度（作业调度），中级调度（内存调度），低级调度（进程调度）控制代码区执行代码的切换&lt;/li&gt;
&lt;li&gt;静态数据区：存储全局变量、静态变量、常量，常量包括 final 修饰的常量和 String 常量，系统自动分配和回收&lt;/li&gt;
&lt;li&gt;栈区：存储运行方法的形参、局部变量、返回值，由系统自动分配和回收&lt;/li&gt;
&lt;li&gt;堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;堆和栈的区别和联系&#34;&gt;堆和栈的区别和联系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;堆和栈都是指内存空间，不同的是，堆是按需申请、动态分配，并且需要手动释放。栈是由系统自动分配，自动释放，当申请内存超过可用内存时，将报异常提示栈溢出&lt;/li&gt;
&lt;li&gt;栈的内存空间是连续的，堆的内存空间则不是。当收到申请空间的请求时，遍历操作系统中记录空闲内存地址的链表，寻找第一个空间大于所申请空间的堆结点，并将此结点从空闲结点链表中删除&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;队列-queue&#34;&gt;队列 Queue&lt;/h2&gt;
&lt;h3 id=&#34;队列数据结构的特点&#34;&gt;“队列”数据结构的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先进者先出（类似于排队）&lt;/li&gt;
&lt;li&gt;是一种“操作受限”的线性表（只有 入队 enqueue、出队 dequeue 操作）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;队列的实现&#34;&gt;队列的实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;顺序队列，用数组实现的队列
&lt;ol&gt;
&lt;li&gt;有两个指针，分别指向 队列头、队列尾&lt;/li&gt;
&lt;li&gt;入队操作，时间复杂度 O（1）
&lt;ul&gt;
&lt;li&gt;由于数组的特性，当队列需要调整长度时，需要数据搬移操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出队操作，均摊复杂度 O（1）
&lt;ul&gt;
&lt;li&gt;每次出队，需要删除数组的第一个元素，若仍旧需要使队列头指向数组的第一个元素，则需要数据搬移，时间复杂度为 O（n）&lt;/li&gt;
&lt;li&gt;优化：在队列无空闲空间时，触发一次数据的搬移操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;链式队列，用链表实现的队列
&lt;ol&gt;
&lt;li&gt;有两个指针，分别指向队列头、队列尾&lt;/li&gt;
&lt;li&gt;入队操作，时间复杂度 O（1）
&lt;ul&gt;
&lt;li&gt;由于链表的特性，可以实现长度无限的队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出队操作，时间复杂度 O（1）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;循环队列，队列头、队列尾相连结的队列，一般用数组实现
&lt;ul&gt;
&lt;li&gt;双指针
&lt;ol&gt;
&lt;li&gt;有两个指针，分别指向队列头、队列尾&lt;/li&gt;
&lt;li&gt;入队操作，时间复杂度 O（1）
&lt;ul&gt;
&lt;li&gt;避免了顺序队列的数据搬移工作，循环入队&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出队操作，时间复杂度 O（1）&lt;/li&gt;
&lt;li&gt;注意事项
&lt;ul&gt;
&lt;li&gt;确定好队空和队满的判定条件，队空 head == tail、队满 （tail + 1）% n = head （head + tail + 1 = n）&lt;/li&gt;
&lt;li&gt;循坏时，头尾指针的位置要取模&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;头指针 + 队列长度
&lt;ol&gt;
&lt;li&gt;入队操作，时间复杂度O（1）&lt;/li&gt;
&lt;li&gt;出队操纵，时间复杂度O（1）&lt;/li&gt;
&lt;li&gt;注意事项
&lt;ul&gt;
&lt;li&gt;确定好队空和队满的判定条件，队空 count == head、队满 count == limit&lt;/li&gt;
&lt;li&gt;循环时，头指针的位置要取模，head = ( head + 1 ) % limit，尾指针，tail = ( head + count ) % limit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双端循环队列，可以分别从队列头、队列尾执行出队、入队操作
&lt;ol&gt;
&lt;li&gt;在队列中预留一个位置，使用两个指针，分别指向队列头、队列尾的下一个位置&lt;/li&gt;
&lt;li&gt;注意事项：
&lt;ul&gt;
&lt;li&gt;确定好队空和队满的判定条件，队空 head == tail、队满 ( tail + 1 ) % limit == head&lt;/li&gt;
&lt;li&gt;循环时，头尾指针的位置要取模，head = ( head + limit - 1 ) % limit，tail = ( tail + 1 ) % limit&lt;/li&gt;
&lt;li&gt;头指针先取模，再赋值，尾指针先赋值，再取模&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;阻塞队列
&lt;ol&gt;
&lt;li&gt;在队列的基础上增加阻塞操作&lt;/li&gt;
&lt;li&gt;在队列为空时，从队列头取数据会被阻塞，在队列满时，入队操作被阻塞&lt;/li&gt;
&lt;li&gt;生产者 - 消费者模型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;并发队列
&lt;ol&gt;
&lt;li&gt;线程安全的队列，同一时刻仅允许一个入队或出队操作&lt;/li&gt;
&lt;li&gt;可以使用基于数组的循环队列，利用 CAS 原子操作
&lt;ul&gt;
&lt;li&gt;入队操作，比较入队前和入队时的 tail，若无变化，则允许入队&lt;/li&gt;
&lt;li&gt;出队操作，比较出队前和出队时的 head，若无变化，则允许出队&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构（一）线性表 — 数组、链表</title>
        <link>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</link>
        <pubDate>Wed, 23 Aug 2023 19:02:18 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E7%BA%BF%E6%80%A7%E8%A1%A8-%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</guid>
        <description>&lt;h2 id=&#34;线性表&#34;&gt;线性表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;每个线性表上的数据最多只有前和后两个方向，如 数组、链表、队列、栈 等&lt;/li&gt;
&lt;li&gt;非线性表，数据之间不是简单的前后关系，如 二叉树、堆、图 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数组-array&#34;&gt;数组 Array&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;线性表数据结构&lt;/li&gt;
&lt;li&gt;连续的内存空间和相同类型的数据
&lt;ul&gt;
&lt;li&gt;利：“随机访问” 的前提条件&lt;/li&gt;
&lt;li&gt;弊：删除、插入操作变得低效，为保证连续性，需要做大量的数据搬移工作&lt;/li&gt;
&lt;li&gt;寻址公式：a[i]_address = base_address + i * data_type_size（为什么数组下标以 0 开始，下标意味着“偏移（offset）”）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;改进数组的插入删除操作&#34;&gt;改进数组的插入、删除操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;改进插入操作，插入第 k 个位置的元素
&lt;ul&gt;
&lt;li&gt;普通：k～n 的元素顺序后移一位&lt;/li&gt;
&lt;li&gt;改进：插入第 k 个位置，并直接将第 k 位的数据搬移到数组元素的最后&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;改进删除操作，删除第 k 个位置的元素
&lt;ul&gt;
&lt;li&gt;普通：k～n 的元素顺序前移一位&lt;/li&gt;
&lt;li&gt;改进：
&lt;ul&gt;
&lt;li&gt;将多次删除操作集中在一起执行，减少删除操作导致的数据搬移。每次的删除操作并不是真正地删除并搬移数据，而是记录数据已经被删除，当数组没有更多空间存储数据时，触发一次真正的删除操作。（JVM 标记清除垃圾回收算法）&lt;/li&gt;
&lt;li&gt;将最后一位的数据搬移至 k&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数组的访问越界问题&#34;&gt;数组的访问越界问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;访问数组的本质是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，程序就可能不会报任何的错误&lt;/li&gt;
&lt;li&gt;数组的访问越界问题，和编译器分配内存和字节对齐有关&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;容器和数组的选择&#34;&gt;容器和数组的选择&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;容器可以将很多数组操作的细节封装起来，支持动态扩容&lt;/li&gt;
&lt;li&gt;Java ArrayList，在创建的时候事先指定数据大小&lt;/li&gt;
&lt;li&gt;Java ArrayList 无法存储基本类型，若特别关注性能或只使用基本类型，可以选用数组&lt;/li&gt;
&lt;li&gt;表示多维数组时，使用数组更加直观&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链表-linked-list&#34;&gt;链表 Linked List&lt;/h2&gt;
&lt;h3 id=&#34;常见的链表结构&#34;&gt;常见的链表结构&lt;/h3&gt;
&lt;h4 id=&#34;单链表&#34;&gt;单链表&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/single_link_list.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/single_link_list.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;单链表&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;单链表&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个结点都有存储数据和记录下一个结点的地址（后继指针 next）&lt;/li&gt;
&lt;li&gt;第一个结点，称作头结点，最后一个结点，称作尾结点，尾结点的 next 指向一个空地址 NULL
&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/single_link_list.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/single_link_list.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;单链表操作&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;单链表操作&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;循环链表&#34;&gt;循环链表&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/loop_link_list.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/loop_link_list.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;循环链表.jpg&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;循环链表.jpg&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;循环链表是一种特殊的单链表，尾结点指针只想链表的头结点&lt;/li&gt;
&lt;li&gt;要处理的数据具有环形结构特点，如 &lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;约瑟夫问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;双向链表&#34;&gt;双向链表&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/two_way_link_list.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/two_way_link_list.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;双向链表&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;双向链表&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个结点有一个后继指针 next 指向后面的结点，有一个前驱指针 prev 指向前面的结点，头结点的 prev、尾结点的 next 指向 NULL&lt;/li&gt;
&lt;li&gt;比单链表占用更多的内存空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;双向循环链表&#34;&gt;双向循环链表&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/two_way_loop_link_list.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/two_way_loop_link_list.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;双向循环链表&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;双向循环链表&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双向链表 + 循环链表&lt;/li&gt;
&lt;li&gt;每个结点有一个后继指针 next 指向后面的结点，有一个前驱指针 prev 指向前面的结点，头结点的 prev 指向 尾结点，尾结点的 next 指向 头结点&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;链表的删除操作&#34;&gt;链表的删除操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;删除结点中“值等于某个给定值”的结点，时间复杂度：O（n）
&lt;ol&gt;
&lt;li&gt;从头结点开始，依次遍历对比，直到找到值等于给定值的结点&lt;/li&gt;
&lt;li&gt;删除结点操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;删除给定指针指向的结点
&lt;ol&gt;
&lt;li&gt;单链表，时间复杂度：O（n）
&lt;ul&gt;
&lt;li&gt;获取要删除结点的前驱结点，从头结点开始依次遍历&lt;/li&gt;
&lt;li&gt;删除结点操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双向链表，时间复杂度：O（1）
&lt;ul&gt;
&lt;li&gt;直接获取前驱结点&lt;/li&gt;
&lt;li&gt;删除结点操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序链表&#34;&gt;有序链表&lt;/h3&gt;
&lt;p&gt;对于一个有序链表，双向链表的按值查询，可以通过记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定往前还是往后查找，平均只需要查找一半的数据&lt;/p&gt;
&lt;h3 id=&#34;数组-vs-链表&#34;&gt;数组 VS 链表&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数组的储存空间是连续的，可以借助 CPU 的缓存机制，预读数组中的数据，链表则不行&lt;/li&gt;
&lt;li&gt;数组的大小是固定的，可能会出现“内存不足”、“重新申请并拷贝操作”（费时），链表没有限制，天然地支持动态扩容&lt;/li&gt;
&lt;li&gt;链表需要储存指针，使用的内存比数组多&lt;/li&gt;
&lt;li&gt;对链表进行频繁的插入、删除操作，会导致频繁的内存申请和释放，容易造成内存碎片（Java 可能会导致频繁 GC）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;链表的应用场景&#34;&gt;链表的应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LRU 缓存淘汰算法（Least Recently Used 最近最少使用）
&lt;ol&gt;
&lt;li&gt;有序单链表，越靠近尾部的结点是越早之前访问的&lt;/li&gt;
&lt;li&gt;有新数据被访问时，从头结点依次遍历&lt;/li&gt;
&lt;li&gt;如果数据已经被缓存在链表中了，找到原本此结点的位置，删除，插入到链表的头部&lt;/li&gt;
&lt;li&gt;如果数据未被缓存，并且缓存未满，则直接插入到链表的头部&lt;/li&gt;
&lt;li&gt;如果数据未被缓存，并且缓存已满，则删除链表的尾结点，并将数据插入到链表的头部&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;判断一个字符串是否是回文字符串
&lt;ul&gt;
&lt;li&gt;快慢指针法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链表代码实现的技巧&#34;&gt;链表代码实现的技巧&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;理解指针或引用的含义
&lt;ul&gt;
&lt;li&gt;指针：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;警惕指针丢失和内存泄漏
&lt;ul&gt;
&lt;li&gt;插入结点时，注意操作顺序&lt;/li&gt;
&lt;li&gt;删除结点时，注意内存泄漏问题（手动释放内存空间）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用哨兵简化难度
&lt;ul&gt;
&lt;li&gt;针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理&lt;/li&gt;
&lt;li&gt;有哨兵结点的链表叫 带头链表，没有哨兵结点的链表叫作 不带头链表
&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/header_link_list.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/header_link_list.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;带头链表&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;带头链表&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;留意边界条件处理
&lt;ul&gt;
&lt;li&gt;链表为空&lt;/li&gt;
&lt;li&gt;链表只包含一个结点&lt;/li&gt;
&lt;li&gt;链表只包含两个结点&lt;/li&gt;
&lt;li&gt;代码逻辑处理头结点和尾结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;举例画图，辅助思考&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多写多练！！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链表代码练习&#34;&gt;链表代码练习&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;单链表反转&lt;/li&gt;
&lt;li&gt;链表中环的检测
&lt;ul&gt;
&lt;li&gt;使用快慢指针，时间复杂度O(n)，空间复杂度O(1)。快指针步长两步，慢指针步长一步，若会相遇，则为有环，若快指针遍历完链表，则为无环&lt;/li&gt;
&lt;li&gt;使用集合，时间复杂度O(n)，空间复杂度O(n)。依次遍历链表，若存在相同结点，则为有环，若遍历完链表，则为无环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两个有序的链表合并
&lt;ul&gt;
&lt;li&gt;新增头结点，依次比较两个链表的结点，顺序在头结点后连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除链表倒数第 n 个结点
&lt;ul&gt;
&lt;li&gt;先使用快慢指针找到倒数第 n 个结点&lt;/li&gt;
&lt;li&gt;若无第 n 个结点，则删除第一个结点或不执行删除操作&lt;/li&gt;
&lt;li&gt;删除第 n 个结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;求链表的中间结点
&lt;ul&gt;
&lt;li&gt;使用快慢指针，当快指针指向尾结点时，慢指针指向中间结点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>如何学习算法</title>
        <link>https://boxtsecond.github.io/2023/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</link>
        <pubDate>Wed, 23 Aug 2023 18:44:08 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h2 id=&#34;学习的步骤&#34;&gt;学习的步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;这个东西是什么，重点是什么&lt;/li&gt;
&lt;li&gt;为什么需要学这个东西&lt;/li&gt;
&lt;li&gt;怎么学这个东西&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构与算法&#34;&gt;数据结构与算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;是什么
&lt;ul&gt;
&lt;li&gt;数据结构：一组数据的存储结构&lt;/li&gt;
&lt;li&gt;算法：操作数据的一组方法&lt;/li&gt;
&lt;li&gt;数据结构为算法服务，算法要作用在特定的数据结构之上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重点是什么
&lt;ul&gt;
&lt;li&gt;复杂度分析&lt;/li&gt;
&lt;li&gt;10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树&lt;/li&gt;
&lt;li&gt;10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么要学
&lt;ul&gt;
&lt;li&gt;修炼自己的内功、锻炼自己的逻辑思维能力&lt;/li&gt;
&lt;li&gt;成为 top 程序员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;怎么学
&lt;ul&gt;
&lt;li&gt;边学边练，适度刷题（python、java、c++、js）&lt;/li&gt;
&lt;li&gt;多思考、多互动&lt;/li&gt;
&lt;li&gt;坚持学会、掌握，练习&lt;/li&gt;
&lt;li&gt;反复三遍&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;衡量算法的优劣----复杂度分析&#34;&gt;衡量算法的优劣 &amp;ndash; 复杂度分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;时间复杂度分析，衡量执行算法消耗的时间&lt;/li&gt;
&lt;li&gt;空间复杂度分析，衡量执行算法消耗的存储空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为什么要复杂度分析&#34;&gt;为什么要复杂度分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;与普通的事后统计法相比较
&lt;ol&gt;
&lt;li&gt;测试结果非常依赖测试环境&lt;/li&gt;
&lt;li&gt;测试结果受数据规模的影响很大&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;需要一种衡量标准来描述算法的优劣，并且跟测试数据、测试环境无关&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;怎么做复杂度分析&#34;&gt;怎么做复杂度分析&lt;/h2&gt;
&lt;h3 id=&#34;时间复杂度分析&#34;&gt;时间复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;执行算法的时间随数据规模增长的变化趋势&lt;/li&gt;
&lt;li&gt;T(n) = O(f(n))
&lt;ul&gt;
&lt;li&gt;T(n) 代码的执行时间&lt;/li&gt;
&lt;li&gt;f(n) 代码的执行次数总和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只关注循环执行次数最多的一段代码&lt;/li&gt;
&lt;li&gt;加法法则：总复杂度等于量级最大的那段代码的复杂度
&lt;ul&gt;
&lt;li&gt;T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
&lt;ul&gt;
&lt;li&gt;T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常见的时间复杂度
&lt;ul&gt;
&lt;li&gt;多项式量级
&lt;ul&gt;
&lt;li&gt;O(1)，代码中不存在循环、递归语句&lt;/li&gt;
&lt;li&gt;O(logn)、O(nlogn)，对数阶时间复杂度，以步长做循环&lt;/li&gt;
&lt;li&gt;O(m+n)、O(m*n)，两个数据的规模决定时间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非多项式量级：O(2n) 和 O(n!)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/algorithm/img/analysis.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/algorithm/img/analysis.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;复杂度量级&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;复杂度量级&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;空间复杂度分析&#34;&gt;空间复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;算法的存储空间与数据规模之间的增长关系&lt;/li&gt;
&lt;li&gt;常见的空间复杂度：O(1)、O(n)、O(n ^ 2)&lt;/li&gt;
&lt;li&gt;除了原本的数据存储空间外，算法运行需要额外的存储空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;更全面的复杂度分析&#34;&gt;更全面的复杂度分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;最好情况时间复杂度（best case time complexity）➡️  最理想的情况&lt;/li&gt;
&lt;li&gt;最坏情况时间复杂度（worst case time complexity）➡️  最糟糕的情况&lt;/li&gt;
&lt;li&gt;平均情况时间复杂度（average case time complexity）
&lt;ul&gt;
&lt;li&gt;加权平均时间复杂度、期望时间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;均摊时间复杂度（amortized time complexity）
&lt;ul&gt;
&lt;li&gt;有一定的前后时序关系&lt;/li&gt;
&lt;li&gt;大部分情况下时间复杂度都相同，个别情况不同&lt;/li&gt;
&lt;li&gt;一般情况下，均摊时间复杂度等于最好情况时间复杂度&lt;/li&gt;
&lt;li&gt;是一种特殊的平均时间复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决方案的思考过程&#34;&gt;解决方案的思考过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义清楚问题
&lt;ul&gt;
&lt;li&gt;调研问题&lt;/li&gt;
&lt;li&gt;对模糊的需求进行假设，限定要解决的问题的范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理解隐藏需求
&lt;ul&gt;
&lt;li&gt;需求一般可以分为功能性需求和非功能性需求&lt;/li&gt;
&lt;li&gt;功能性需求一般来讲是和业务逻辑紧密相关的&lt;/li&gt;
&lt;li&gt;非功能性需求包括安全、性能、用户体验等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尝试用学过的数据结构解决这个问题
&lt;ul&gt;
&lt;li&gt;尝试对比多种数据结构&lt;/li&gt;
&lt;li&gt;如果不能直接使用基本数据结构解决，尝试改造数据结构，可以结合多个数据结构的不同特点，使用多个数据结构尝试解决&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算时间、空间复杂度，包括对内存、磁盘的访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;合理地选择数据结构和算法&#34;&gt;合理地选择数据结构和算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;熟知每种数据结构和算法的功能、特点、时间空间复杂度&lt;/li&gt;
&lt;li&gt;时间、空间复杂度不能跟性能划等号
&lt;ul&gt;
&lt;li&gt;复杂度不是执行时间和内存消耗的精确值，会忽略低阶、常数、系数&lt;/li&gt;
&lt;li&gt;处理小规模数据时，代码的执行时间有时不跟时间复杂度成正比&lt;/li&gt;
&lt;li&gt;对于处理不同问题的不同算法，复杂度没有可比性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算法的选择，一定要根据数据规模来抉择。数据规模小的时候，不必选择高级算法，而是选择简单、易维护、易实现的算法&lt;/li&gt;
&lt;li&gt;解决问题的重点在于对需求的调研、理解，理清楚要处理数据的特征与访问方式&lt;/li&gt;
&lt;li&gt;区别对待 IO 密集、内存密集、计算密集
&lt;ul&gt;
&lt;li&gt;数据在磁盘上，代码的性能瓶颈可能在磁盘 IO，要尽可能地减少磁盘 IO 的次数&lt;/li&gt;
&lt;li&gt;数据在内存中，判断代码是内存密集型还是 CPU 密集型
&lt;ul&gt;
&lt;li&gt;CPU 密集型，CPU 计算耗时占大部分，在选择数据结构和算法的时候，要尽量减少逻辑计算的复杂度，如 用位运算代替加减乘除等&lt;/li&gt;
&lt;li&gt;内存密集型，内存数据的读取耗时占大部分，可以考虑是否能减少数据的读取量，数据是否在内存中连续存储，是否能利用 CPU 缓存预读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用现有算法，避免重复造轮子&lt;/li&gt;
&lt;li&gt;不要漫无目的地过度优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;学习书单&#34;&gt;学习书单&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;《大话数据结构》&lt;/li&gt;
&lt;li&gt;《算法图解》&lt;/li&gt;
&lt;li&gt;《数据结构和算法分析》&lt;/li&gt;
&lt;li&gt;《剑指 offer》&lt;/li&gt;
&lt;li&gt;《编程珠玑》&lt;/li&gt;
&lt;li&gt;《编程之美》&lt;/li&gt;
&lt;li&gt;《算法》&lt;/li&gt;
&lt;li&gt;《算法导论》&lt;/li&gt;
&lt;li&gt;《计算机程序设计艺术》&lt;/li&gt;
&lt;li&gt;《算法帝国》&lt;/li&gt;
&lt;li&gt;《数学之美》&lt;/li&gt;
&lt;li&gt;《算法之美》&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>快速理解网络协议（三）MAC 层</title>
        <link>https://boxtsecond.github.io/2023/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%89mac-%E5%B1%82/</link>
        <pubDate>Wed, 23 Aug 2023 17:16:32 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%89mac-%E5%B1%82/</guid>
        <description>&lt;h1 id=&#34;快速理解网络协议三mac-层&#34;&gt;快速理解网络协议（三）MAC 层&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/mac.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/mac.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;总览&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;总览&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;物理层-physical-layer&#34;&gt;物理层 Physical Layer&lt;/h1&gt;
&lt;p&gt;虽然 TCP/IP 模型不涉及硬件设备所在的物理层，但还是在这里简单介绍下物理层。&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;物理层，顾名思义，表示实际的物理链接。物理层利用物理传输介质为通信的两端建立链接，实现比特流的传输，如铜线、光缆或无线通道，保证比特流正确的传输到对端。常见设备包括&lt;strong&gt;中继器、集线器&lt;/strong&gt;等。其中集线器 Hub，完全在物理层工作，会将自己收到的每一个字节，都复制到其他端口上去，即广播模式。&lt;/p&gt;
&lt;h1 id=&#34;mac-层-link-layer&#34;&gt;&lt;strong&gt;MAC 层 Link Layer&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;链路层，又称 MAC 层。MAC 的全称为 Medium Access Control，即媒体访问控制，主要有两个功能，&lt;strong&gt;寻址和控制&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;寻址，即如何找到数据包接收方&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制，即谁先发、谁后发，发送出现问题如何处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决控制问题&#34;&gt;&lt;strong&gt;解决“控制”问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在以太网中，两个节点间传输的数据最终都会转换成电信号，在物理传输介质上发送出去。物理传输介质肯定是共享的，在发送数据时需要考虑谁先发、谁后发、同时发送时怎么避免冲突、出现问题怎么处理等。**这就是多路访问问题，即如何协调多个发送和接收节点对单一共享广播信道的访问。**计算机网络使用多路访问协议来规范它们在共享的广播信道上的传输行为。&lt;/p&gt;
&lt;h3 id=&#34;多路访问协议&#34;&gt;&lt;strong&gt;多路访问协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们可以先来思考一下，理想情况下在共享信道上期望怎么传输数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果只有一个节点需要发送数据，那么我们期望它可以以整个信道的速率 R 发送数据&lt;/li&gt;
&lt;li&gt;如果有 M 个节点需要同时发送数据，那么我们期望它可以以（信道的传输速率 R / M）来发送数据&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;规划车道 ➡️ 信道划分协议 Channel Partitioning Protocol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用多路复用技术，将链路、网络资源（如带宽）划分为“资源片”，将“资源片”分配给各路通信，每路通信&lt;strong&gt;独占&lt;/strong&gt;其分配到的资源片进行通信。这样的划分方式，可以满足理想情况 2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依次排队&lt;/strong&gt; ➡️ &lt;strong&gt;轮转协议 Taking-turns Protocol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个节点轮流发送数据。当只有一个结点活跃时，以信道的全部发送速率 R 发送；当有M个结点活跃时，每个活跃结点的吞吐量接近 R/M。完全满足理想情况 1，几乎满足理想情况 2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;随机应变&lt;/strong&gt; ➡️ &lt;strong&gt;随机访问协议 Random Access Protocol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;节点总是以信道的全部速率发送数据，传输时可能且允许出现冲突。当检测到冲突时通过延时重传等方式恢复，**这也是以太网使用的方式。**完全满足理想情况 1，几乎满足理想情况 2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在轮转协议和随机访问协议中，好像都可以满足理想情况。那为什么以太网使用的说随机访问协议而不是轮转协议呢？主要有以下三个原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;网络架构更简单&lt;/strong&gt;，所有设备都可以同时发送和接收数据，不需要等待其他设备的轮转时机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更加灵活和高效&lt;/strong&gt;，随机访问协议允许多个设备同时发送数据，不需要进行时间调度或协调&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性高&lt;/strong&gt;，新设备可以随时连接到网络，并立即开始发送和接收数据，不需要调度或配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决寻址问题&#34;&gt;&lt;strong&gt;解决“寻址”问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;MAC 地址是指网络设备的硬件地址，是由网络设备的制造商烧录在设备的网卡中的一个全球唯一的地址，如果一台设备有多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。MAC 地址共 48 位（6个字节），以十六进制表示。&lt;/p&gt;
&lt;p&gt;当数据传输时，源设备会根据目标设备的 MAC 地址 “寻址” ，确保数据能够被正确地传送到目标设备。当设备接收到数据后，如果发现目的地址与本地 MAC 地址不一致，则会丢弃，只有真正的目标设备才会接收并处理收到的数据。&lt;/p&gt;
&lt;p&gt;MAC 地址是一个局域网（LAN）范围内的地址，它只在局域网中起作用，不能直接进行跨网络通信。在局域网中，可以通过交换机（Switch）来完成数据的传输。交换机通过学习和记录连接到它的设备的 MAC 地址，根据 MAC 地址来决定数据的转发。而在互联网中，数据通常是通过路由器（Router）等设备进行转发，而不是根据 MAC 地址进行直接传输。&lt;/p&gt;
&lt;h3 id=&#34;以太网帧---frame&#34;&gt;&lt;strong&gt;以太网帧 - Frame&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;以太网帧 Ethernet frame 是 MAC 层传输数据的基本单位&lt;/strong&gt;。其中 MAC 头部包含 目标 MAC 地址、源 MAC 地址 和 类型。类型标识了传输数据的封装协议&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。常见的类型有，0x0800 表示 IPv4 数据报，0x0806 表示 ARP 数据报，0x86DD 表示 IPv6 数据报&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/mac_frame.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/mac_frame.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;frame&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;frame&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标 MAC 地址：表示数据包应该被发送到哪个网络设备，由 6 个字节组成&lt;/li&gt;
&lt;li&gt;源 MAC 地址：表示数据包是从哪个网络设备发送的，同样由 6 个字节组成&lt;/li&gt;
&lt;li&gt;类型：表示数据包类型，0800 表示 IP 数据包，0806 表示 ARP 数据包&lt;/li&gt;
&lt;li&gt;数据：实际的数据内容，长度可变&lt;/li&gt;
&lt;li&gt;CRC：Cyclic Redundancy Check 循环冗余检测，通过 XOR 异或的算法，计算整个数据包在发送的过程中是否出现了错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;获取-mac-地址&#34;&gt;&lt;strong&gt;获取 MAC 地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在网络通信中，使用 MAC 地址直接进行通信是不可行的，我们借助 IP 地址作为中间桥梁来实现通信。在局域网中，知道了要发送的 IP 地址，该如何获得目标设备的 MAC 地址呢？&lt;/p&gt;
&lt;p&gt;每个设备的网卡的 MAC 地址都是固定的，我们可以手动一个个添加局域网中其他设备的 MAC 地址，随着局域网中的主机越来越多，这种方式难以为继。我们需要自动获取、更新和维护各个设备的 MAC 地址，这就是 Address Resolution Protocol。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP 协议，工作在 MAC 层，用于获得已知 IP 地址的 MAC 地址&lt;/strong&gt;。而手动配置 MAC 地址的方式，一般是出于安全考虑，为了防止非法用户访问，由网络管理员手动在 MAC 地址表中添加合法用户的 MAC 地址表项，当手动配置的数量比较大时，难以人工维护，可以使用端口安全功能实现 MAC 地址和接口的动态绑定。&lt;/p&gt;
&lt;p&gt;具体的 ARP 协议内容，我们下节继续～&lt;/p&gt;
&lt;h2 id=&#34;小测验&#34;&gt;&lt;strong&gt;小测验&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在物理层工作的常见设备有哪些？&lt;/li&gt;
&lt;li&gt;在 MAC 层工作的常见设备有哪些？&lt;/li&gt;
&lt;li&gt;MAC 层传输数据的基本是什么？它的头的格式是什么？每个字段的含义和作用是什么？&lt;/li&gt;
&lt;li&gt;如何通过 IP 地址获取 MAC 地址？&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;有些文章描述 TCP/IP 模型有五层，其中包括了物理层 Physical Layer。但在 RFC 1122 中未指定物理层，我还是倾向于四层。详情可参考：https://datatracker.ietf.org/doc/html/rfc1122#page-8&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;以太网II帧：https://en.wikipedia.org/wiki/Ethernet_frame#Ethernet_II&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;更多类型含义：https://en.wikipedia.org/wiki/EtherType#Values&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>快速理解网络协议（二）TCP/IP 协议模型</title>
        <link>https://boxtsecond.github.io/2023/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BA%8Ctcp/ip-%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Wed, 23 Aug 2023 14:52:03 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BA%8Ctcp/ip-%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipmac.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipmac.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;总览&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;总览&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcpip-协议模型&#34;&gt;&lt;strong&gt;TCP/IP 协议模型&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/tcpip.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/tcpip.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;TCP/IP 协议模型&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;TCP/IP 协议模型&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们从下往上依次介绍这些层级，有一个很重要的原因是，&lt;strong&gt;在网络中传输的数据包，会按照这些层级来封装报文，一个数据包只可能有下层没上层，绝不会有上层没下层（这句话要牢牢记住）。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层级&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;在此层的协议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;链路层&lt;/td&gt;
&lt;td&gt;负责节点之间数据的传输控制和寻址&lt;/td&gt;
&lt;td&gt;ATM, PPP 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td&gt;负责数据包的路由和转发&lt;/td&gt;
&lt;td&gt;IP, ICMP, OSPF 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td&gt;负责数据端到端之间的具体传输行为控制&lt;/td&gt;
&lt;td&gt;TCP, UDP 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td&gt;负责不同应用使用的通信协议的数据封装&lt;/td&gt;
&lt;td&gt;HTTP, SMTP, FTP, DNS, SSH 等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;链路层&#34;&gt;&lt;strong&gt;链路层&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;链路层负责节点之间数据的传输控制和寻址，重点在于&lt;strong&gt;控制和寻址。控制，即谁先发，谁后发，发送时出现问题如何处理，寻址，即如何找到数据包的接收方。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决 “控制” 问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络中的链路分为两种类型，点对点链路 和 广播链路。点对点链路，由链路一端的单个发送方和链路另一端的单个接收方组成，如 点对点协议（PPP，Point-to-Point Protocol）、高级数据链路控制（HDLC，High-level Data Link Control）。广播链路，能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。很明显，在点对点链路中，由于只有两个节点参与通信，因此不需要进行数据传输的控制，“控制“ 主要解决的问题是如何协调多个发送和接收节点对单一共享广播信道的访问，即**多路访问问题。**为了解决多路访问问题，于是出现了多路访问控制协议，Multiple Access Control 简称 MAC。&lt;/p&gt;
&lt;p&gt;常见的多路访问协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信道划分协议 Channel Partitioning Protocol&lt;/li&gt;
&lt;li&gt;采用多路复用技术，将链路、网络资源（如带宽）划分为“资源片”，将“资源片”分配给各路通信，每路通信独占其分配到的资源片进行通信&lt;/li&gt;
&lt;li&gt;轮转协议 Taking-turns Protocol&lt;/li&gt;
&lt;li&gt;多个节点轮流发送数据&lt;/li&gt;
&lt;li&gt;当只有一个结点活跃时，以信道的全部发送速率 R 发送；当有M个结点活跃时，每个活跃结点的吞吐量接近 R/M&lt;/li&gt;
&lt;li&gt;随机访问协议 Random Access Protocol&lt;/li&gt;
&lt;li&gt;以信道的全部速率发送数据，检测到冲突时通过延时重传等方式恢复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以太网使用的方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决 “寻址” 问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里要用到一个物理地址，叫作链路层地址，或 MAC 地址。&lt;strong&gt;MAC 地址用于在网络中唯一标示一个网卡（并不是设备）&lt;/strong&gt;，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。&lt;/p&gt;
&lt;p&gt;在此层的头部一般被称为 MAC 头。具体格式如下图橙色部分&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/macheader.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/macheader.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;MAC 头&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;MAC 头&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标 MAC 地址：表示数据包应该被发送到哪个网络设备，由 6 个字节组成&lt;/li&gt;
&lt;li&gt;源 MAC 地址：表示数据包是从哪个网络设备发送的，同样由 6 个字节组成&lt;/li&gt;
&lt;li&gt;类型：表示数据包类型，0800 表示 IP 数据包，0806 表示 ARP 数据包&lt;/li&gt;
&lt;li&gt;数据：实际的数据内容，长度可变&lt;/li&gt;
&lt;li&gt;CRC：Cyclic Redundancy Check 循环冗余检测，通过 XOR 异或的算法，计算整个数据包在发送的过程中是否出现了错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;网络层&#34;&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;网络层负责数据包的路由和转发，重点在于&lt;strong&gt;路由，即选择合适的路径转发到目标主机。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络层使用 IP 协议来提供基本的数据传输服务，包括数据包的路由、分组和转发等功能。IP 协议使用 &lt;strong&gt;IP 地址唯一标识网络中的设备&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;IP 地址主要有两个作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位，即提供设备网络中的“位置”信息&lt;/li&gt;
&lt;li&gt;路由，即数据包选择什么 “路径” 到达目标设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此层的头部一般被称为 IP 头。IPv4 头具体格式如图所示&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipheader.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipheader.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;IPv4 头&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;IPv4 头&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;IPv4 头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本：指定 IP 协议的版本，4 表示 IPv4，占用 4 bits&lt;/li&gt;
&lt;li&gt;首部长度 IHL：表示 IP 头的长度，占用 4 bits&lt;/li&gt;
&lt;li&gt;区分服务：用于标识网络中不同类型的数据流，只有在使用区分服务时，此字段才有作用，占用 6 bits&lt;/li&gt;
&lt;li&gt;显示拥塞通告：可选功能，在两端都支持且底层网络支持时可被使用，占用 2 bits&lt;/li&gt;
&lt;li&gt;全长：IP 数据报总长度，包括 IP 首部和 IP 数据部分的长度，占用 16 bits&lt;/li&gt;
&lt;li&gt;标识符：唯一标识一个 IP 数据报的所有分片，占用 16 bits&lt;/li&gt;
&lt;li&gt;标志：用于控制和识别报文的分片，占用 3 bits&lt;/li&gt;
&lt;li&gt;分片偏移：用于标识每个分片相对于原始报文开头的偏移量，占用 13 bits&lt;/li&gt;
&lt;li&gt;生存时间：用于防止 IP 数据报在网络中无限循环，作为跳数计数器，每经过一个路由都会减 1，为0时，将丢弃该数据报，占用 8 bits&lt;/li&gt;
&lt;li&gt;协议：表示 IP 数据报中使用的上层协议类型，例如 TCP、UDP 等，占用 8 bits&lt;/li&gt;
&lt;li&gt;首部校验和：用于检验 IP 首部（不包括数据部分）在传输过程中是否有错，占用 16 bits&lt;/li&gt;
&lt;li&gt;源地址：IP 数据报的源地址&lt;/li&gt;
&lt;li&gt;目的地址：IP 数据报的目的地址&lt;/li&gt;
&lt;li&gt;选项：其他附加信息，首部长度必须是 32 的倍数，若不满足则填充 EOL（0x00），直至满足&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;传输层&#34;&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;传输层负责数据端到端之间的具体传输行为控制，重点在于&lt;strong&gt;端到端和传送控制。端到端，即将数据具体送达至哪个程序，传送控制，即如何将数据送达到目的地。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输层上有两个最重要也最常见的协议，TCP 和 UDP，用于端到端的数据传输控制。这两块的内容比较复杂和重要，后面会专门拿出来单独说明，在此就先不赘述了。&lt;/p&gt;
&lt;h3 id=&#34;应用层&#34;&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;应用层负责不同应用使用的通信协议的数据封装，重点在于&lt;strong&gt;通信协议的数据封装，即在通信时按照哪种格式如何封装数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用层上的协议是和我们日常开发息息相关的，比如程序使用 HTTP 协议发送一个 HTTP 请求、使用 SMTP 协议向客户发送一封邮件等等。在应用层上，每个协议的封装和解析是协议特有的，HTTP 协议的数据不能被 SMTP 协议解析。&lt;/p&gt;
&lt;h2 id=&#34;分层的原因&#34;&gt;&lt;strong&gt;分层的原因&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;任何复杂、大型的工程都需要分层来实现模块化，用来降低不同模块之间耦合度，提高模块之间的可替代性和整个工程的复杂度。分层带来的优点有以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低不同层级、模块之间的耦合度，提高网络的灵活性。每层的功能和任务清晰且明确，可以分别设计和实现，使得单一协议或模块的开发、维护、升级变得更加容易。&lt;/li&gt;
&lt;li&gt;提高相同层级内模块的可替代性。比如 DNS 协议，既可以使用 TCP 协议又可以使用 UDP 协议作为传输层协议。&lt;/li&gt;
&lt;li&gt;更低的层级可以统一的向上提供服务，比如传输层的 TCP 协议可以为应用层的 HTTP、FTP 协议等提供服务。&lt;/li&gt;
&lt;li&gt;促进了层级和模块的标准化，使得网络在技术和商业上更加开放和透明。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在日常的开发设计中，我们也要将这种分层的思想融入到自己开发的系统中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块化或分层：将系统按照不同的功能和职责进行分层，使系统的各个部分职责清晰、功能单一、易于维护和扩展。&lt;/li&gt;
&lt;li&gt;标准化：遵循接口规范，对不同层之间的数据传输进行约束和规范，从而提高系统的稳定性、可靠性和可维护性。&lt;/li&gt;
&lt;li&gt;可替代性：通过定义接口和协议来约束不同层之间的数据传输，降低模块间的耦合度，提高模块的可替代性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;小测验&#34;&gt;&lt;strong&gt;小测验&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;TCP/IP 协议模型有几层，它们的作用分别是什么？&lt;/li&gt;
&lt;li&gt;在网络中的数据包，有没有可能有 TCP 头，但是没有 IP 头？如果有的话，举例说明。&lt;/li&gt;
&lt;li&gt;在网络中的数据包，有没有可能有 TCP 头，但是没有 HTTP 头？如果有的话，举例说明。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>快速理解网络协议（一） IP 地址、MAC 地址</title>
        <link>https://boxtsecond.github.io/2023/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%80-ip-%E5%9C%B0%E5%9D%80mac-%E5%9C%B0%E5%9D%80/</link>
        <pubDate>Wed, 23 Aug 2023 14:52:03 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/2023/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%80-ip-%E5%9C%B0%E5%9D%80mac-%E5%9C%B0%E5%9D%80/</guid>
        <description>&lt;p&gt;快速理解网络协议（一），基础知识的补充&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipmac.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipmac.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;总览&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;总览&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;ip-地址&#34;&gt;&lt;strong&gt;IP 地址&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;IP 地址中的 “IP” 代表Internet Protocol（互联网协议），IP 地址是在 IP 协议下使用的地址，IP 地址有三个主要功能：&lt;strong&gt;标识设备或网络、定位和选择路由&lt;/strong&gt;。由于 IPv4 是第一个架构中的主要版本，所以在没有特殊说明的时候，IP 地址一般指的是 IPv4 地址。&lt;/p&gt;
&lt;h3 id=&#34;ipv4-地址&#34;&gt;&lt;strong&gt;IPv4 地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个 IPv4 地址被 “.” 分割成 4 个部分，每个部分 8 个 bit，总共 32 位，使用十进制表示。在设计之初，IPv4 地址被分成 5 类，如下图所示，我们平时接触到的基本是 ABC 三类。一个 IPv4 地址被分为两部分，网络号 + 主机号，这种地址分类的方式叫做&lt;strong&gt;分类网络&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipv4.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/ipv4.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;IPv4地址分类&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;IPv4地址分类&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在分类网络中，A、B、C 三类的 IPv4 地址的数量分割一点都不合理，范围跨度太大了。随着互联网的快速发展，CIDR 取代了分类网络。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CIDR （Classless Inter-Domain Routing ）无类别域间路由&lt;/strong&gt;，旨在重新划分地址空间，将地址块可以较为自由合理的分配给用户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CIDR（“/” 后带着数字这种表示形式，“/” 后）将 32 位的 IP 地址一分为二，网络号 + 主机号，例如 100.100.100.2/24，前 24 位是网络号，后 8 位是主机号&lt;/li&gt;
&lt;li&gt;网络号全为 1 的就是子网掩码，主机号全为 1 的就是广播地址&lt;/li&gt;
&lt;li&gt;将子网掩码和 IP 地址按位计算 AND，可以得到网络号，即&lt;strong&gt;可以判断一个 IP 地址是不是在当前子网内&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt; 100.100.100.2/24&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子网掩码：255.255.255.0&lt;/li&gt;
&lt;li&gt;广播地址：100.100.100.255，所有 100.100.100 网络里面的机器都可以收到&lt;/li&gt;
&lt;li&gt;100.100.100.20 与子网掩码做按位与运算，得到 100.100.100.0，即为网络号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;易错计算：&lt;/strong&gt; 求 16.158.165.91/22 的网络号、第一个地址、子网掩码和广播地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;16.158.165.91/22 → 16.158. 101001/01. 01011011&lt;/li&gt;
&lt;li&gt;网络号：16.158. 101001/00.0 → 16.158.164.0&lt;/li&gt;
&lt;li&gt;第一个地址：16.158.164.1&lt;/li&gt;
&lt;li&gt;子网掩码：255.255.252.0&lt;/li&gt;
&lt;li&gt;广播地址：16.158.167.255&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见特殊-ipv4-地址&#34;&gt;&lt;strong&gt;常见特殊 IPv4 地址&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;127.0.0.1 表示本机地址&lt;/li&gt;
&lt;li&gt;0.0.0.0 有两种含义，默认路由地址和通配符地址。默认路由地址我们之后再说。通配符地址指的是，若进程监听了通配符地址，那么进程监听了本机上的所有 IP 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipv6-地址&#34;&gt;&lt;strong&gt;IPv6 地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于互联网的快速兴起，导致 IPv4 地址很快就不够用了，于是出现了 IPv6 地址。一个 IPv6 地址被 “:” 分为 8 个部分，每个部分以 4 位十六进制方式表示，总共 128 位。比如：2001:0db8:85a3:08d3:1319:8a2e:0370:734。&lt;/p&gt;
&lt;p&gt;IPv6 地址和 IPv4 地址相似，也使用网络号 + 主机号的形式划分。一个 IPv4 地址可以很容易的转换成一个 IPv6 地址，如果一个地址是 IPv4 地址，可以直接表示成，::ffff:IPv4地址，比如 ::ffff:192.168.89.9，这种格式叫做**IPv4映射地址。**而::1 类似于 IPv4 中的 127.0.0.1。&lt;/p&gt;
&lt;h3 id=&#34;ip-地址的功能&#34;&gt;&lt;strong&gt;IP 地址的功能&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标识设备或网络、定位，提供设备在网络中的位置信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择路由，在网络传输中，通过 IP 地址选择路由&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mac-地址&#34;&gt;&lt;strong&gt;MAC 地址&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;和 IP 地址相似，由于此地址作用于 MAC 层，所以称之为 MAC 地址。MAC 地址是指网络设备的硬件地址，是由网络设备的制造商烧录在设备的网卡中的一个&lt;strong&gt;全球唯一&lt;/strong&gt;的地址。类比现实生活的话，IP 地址更像是精确到门牌号的地址信息，而 MAC 地址则是拥有唯一身份证号的“人”。&lt;/p&gt;
&lt;h2 id=&#34;ip-地址-和-mac-地址的区别&#34;&gt;&lt;strong&gt;IP 地址 和 MAC 地址的区别&lt;/strong&gt;&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;区别&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;MAC地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;地址类型&lt;/td&gt;
&lt;td&gt;逻辑地址&lt;/td&gt;
&lt;td&gt;物理地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分配方式&lt;/td&gt;
&lt;td&gt;由运营商分配&lt;/td&gt;
&lt;td&gt;由设备制造商烧录到设备的网卡中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;作用范围&lt;/td&gt;
&lt;td&gt;全球互联网上的通信&lt;/td&gt;
&lt;td&gt;局域网内通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主要功能&lt;/td&gt;
&lt;td&gt;标识设备和选择路由&lt;/td&gt;
&lt;td&gt;唯一标识设备&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;查看-ip-地址mac-地址&#34;&gt;&lt;strong&gt;查看 IP 地址、MAC 地址&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Linux 下使用 ip addr 或 ifconfig，Windows 下使用 ipconfig&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/post/network_protocol/img/ifconfig.png&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/post/network_protocol/img/ifconfig.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;ifconfig&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;ifconfig&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“1” 表示 MAC 地址，是一个网卡的物理地址，使用十六进制，6个 byte表示&lt;/li&gt;
&lt;li&gt;“2” 表示 net_device flags，网络设备的状态标识
&lt;ul&gt;
&lt;li&gt;BROADCAST 表示此网卡有广播地址，可以发送广播包&lt;/li&gt;
&lt;li&gt;MULTICAST 表示此网卡可以发送多播包&lt;/li&gt;
&lt;li&gt;UP 表示此网卡处于启动状态&lt;/li&gt;
&lt;li&gt;LOWER_UP 表示 L1 启动，即网线已插入&lt;/li&gt;
&lt;li&gt;mtu 1500 表示最大传输单元 MTU 为 1500，是以太网的默认值，即正文部分不允许超过 1500 个字节&lt;/li&gt;
&lt;li&gt;qdisc，表示 queueing discipline 排队规则，内核通过网络接口发送数据包时，需要按照 qdisc 配置的规则把数据包加入队列
&lt;ul&gt;
&lt;li&gt;mq，是一个虚拟 qdisc，目的是为网络设备的每个硬件队列创建一个 pfifo_fast 队列&lt;/li&gt;
&lt;li&gt;pfifo，不对数据包做任何处理，先入先出&lt;/li&gt;
&lt;li&gt;pfifo_fast，数据包按照服务类型 TOS Type Of Service（ IP 头中的一个字段）分配到不同的波段中，每个波段对应的优先级不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;小测验&#34;&gt;&lt;strong&gt;小测验&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如何判断一个 IP 地址是否在子网内？&lt;/li&gt;
&lt;li&gt;IP 地址是逻辑地址还是物理地址？它在网络中的作用是什么？&lt;/li&gt;
&lt;li&gt;IP 地址和 MAC 地址的区别？&lt;/li&gt;
&lt;li&gt;MAC 地址是逻辑地址还是物理地址？它在网络中的作用是什么？&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
