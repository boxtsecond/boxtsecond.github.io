<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>排序 on Bo&#39;s Blog</title>
        <link>https://boxtsecond.github.io/zh-cn/tags/%E6%8E%92%E5%BA%8F/</link>
        <description>Recent content in 排序 on Bo&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 24 Aug 2023 12:02:21 +0800</lastBuildDate><atom:link href="https://boxtsecond.github.io/zh-cn/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>常见算法类型（五）排序算法对比</title>
        <link>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%BA%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</link>
        <pubDate>Thu, 24 Aug 2023 12:02:21 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%BA%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</guid>
        <description>&lt;h2 id=&#34;各个排序算法间的比较&#34;&gt;各个排序算法间的比较&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/sort_all.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/sort_all.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;排序算法&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;排序算法&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;如何优化快速排序&#34;&gt;如何优化快速排序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;快速排序的最坏时间复杂度是 O（n^2），出现最坏时间复杂度的原因是分区点选择的不够合理&lt;/li&gt;
&lt;li&gt;最理想的分区点：被分区点分开的两个分区中，数据的数量差不多
&lt;ul&gt;
&lt;li&gt;比较常见的分区算法
&lt;ol&gt;
&lt;li&gt;三数取中法
&lt;ul&gt;
&lt;li&gt;取区间的首、尾、中间 三个数的中间值作为分区点&lt;/li&gt;
&lt;li&gt;如果排序的数组比较大，“三数取中法”可能不够，需要“五数取中”或者“十数取中”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;随机法
&lt;ul&gt;
&lt;li&gt;每次从要排序的区间中，随机选择一个元素作为分区点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;快速排序使用递归实现，要警惕堆栈溢出
&lt;ol&gt;
&lt;li&gt;限制递归深度，一旦递归过深，停止递归&lt;/li&gt;
&lt;li&gt;在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>常见算法类型（四）排序 O(n)：桶排序、计数排序、基数排序</title>
        <link>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E5%9B%9B%E6%8E%92%E5%BA%8F-on%E6%A1%B6%E6%8E%92%E5%BA%8F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 24 Aug 2023 11:59:04 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E5%9B%9B%E6%8E%92%E5%BA%8F-on%E6%A1%B6%E6%8E%92%E5%BA%8F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
        <description>&lt;h2 id=&#34;桶排序-bucket-sort&#34;&gt;桶排序 Bucket Sort&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;思想说明
&lt;ol&gt;
&lt;li&gt;桶排序只包含一种操作，元素的移动，不涉及元素之间的比较操作&lt;/li&gt;
&lt;li&gt;将要排序的数据分到几个有序的桶里，每个桶里的数据单独进行排序&lt;/li&gt;
&lt;li&gt;桶内排序完成后（归并排序），把每个桶里的数据按照顺序依次取出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（n），不是原地排序算法&lt;/li&gt;
&lt;li&gt;最好时间复杂度 O（n），最坏时间复杂度 O（nlog(n)）&lt;/li&gt;
&lt;li&gt;是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;应用场景分析
&lt;ol&gt;
&lt;li&gt;排序的数据需要很容易的划分成 m 个桶&lt;/li&gt;
&lt;li&gt;桶和桶之间有天然的大小关系&lt;/li&gt;
&lt;li&gt;数据在各个桶之间的分布比较均匀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;比较适合用在外部排序中，因数据量较大，内存有限而无法全部加载在内存中&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计数排序-counting-sort&#34;&gt;计数排序 Counting Sort&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;思想说明
&lt;ol&gt;
&lt;li&gt;计数排序只包含一种操作，元素的移动，不涉及元素之间的比较操作&lt;/li&gt;
&lt;li&gt;排序的数据划分成 m 个桶，每个数据对应的值为一个桶，每个桶中存放的是这个值对应的数据个数&lt;/li&gt;
&lt;li&gt;将桶中存放的数据个数依次相加，得到位置数组&lt;/li&gt;
&lt;li&gt;创建和原数据大小一致的数组，&lt;strong&gt;从后到前&lt;/strong&gt;遍历原数据，将数据对应的值的桶中存放的数据个数取出（x），放在创建数组 x-1 的位置上，并将桶中的值 - 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（n），不是原地排序算法&lt;/li&gt;
&lt;li&gt;时间复杂度 O（n）&lt;/li&gt;
&lt;li&gt;是稳定的排序算法（&lt;strong&gt;从后到前&lt;/strong&gt;遍历原数据）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;应用场景分析
&lt;ol&gt;
&lt;li&gt;排序的数据范围比较小&lt;/li&gt;
&lt;li&gt;只能给非负整数排序，如果要排序的数据是其他类型，要在不改变相对大小的情况下，转化为非负整数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基数排序-radix-sort&#34;&gt;基数排序 Radix Sort&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;思想说明
&lt;ol&gt;
&lt;li&gt;将要排序的数据按“位”分割&lt;/li&gt;
&lt;li&gt;从后往前的按照“位”来排序数据，排序数据的算法必须是稳定的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（1），是原地排序算法&lt;/li&gt;
&lt;li&gt;最好时间复杂度 O（n）（“位”次桶排序或计数排序）&lt;/li&gt;
&lt;li&gt;是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;应用场景分析
&lt;ol&gt;
&lt;li&gt;要排序的数据可以分割出独立的“位”来比较，&lt;/li&gt;
&lt;li&gt;“位”之间有递进的关系，若 a 数据的高位比 b 数据的大，则剩下的低位不用比较&lt;/li&gt;
&lt;li&gt;每一“位”的数据范围不能过大，要可以用线性排序算法来排序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>常见算法类型（三）排序 O(nlogn)：归并排序、快速排序、堆排序</title>
        <link>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%B8%89%E6%8E%92%E5%BA%8F-onlogn%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 24 Aug 2023 11:31:06 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%B8%89%E6%8E%92%E5%BA%8F-onlogn%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
        <description>&lt;h2 id=&#34;归并排序merge-sort&#34;&gt;归并排序（Merge Sort）&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/merge_sort.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/merge_sort.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;归并排序&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;归并排序&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思想说明
&lt;ol&gt;
&lt;li&gt;归并排序包含两种操作，一种是元素的比较，一种是元素的移动&lt;/li&gt;
&lt;li&gt;使用分治思想，分而治之，将一个大问题分解成小的字问题来解决&lt;/li&gt;
&lt;li&gt;将数组从中间分成前后两部分，并对前后两部分分别排序&lt;/li&gt;
&lt;li&gt;不断重复 b，直到数组分解完成（归）&lt;/li&gt;
&lt;li&gt;将排好序的两部分合并在一起（并）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（n log(n)），不是原地排序算法&lt;/li&gt;
&lt;li&gt;最好、最坏、平均时间复杂度均为 O（n log(n)）&lt;/li&gt;
&lt;li&gt;不是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快速排序quick-sort&#34;&gt;快速排序（Quick Sort）&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/quick_sort.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/quick_sort.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;快速排序&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;快速排序&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思想说明
&lt;ol&gt;
&lt;li&gt;快速排序包含两种操作，一种是元素的比较，一种是元素的移动&lt;/li&gt;
&lt;li&gt;选择数组中的任意一个元素作为 pivot（分区点）&lt;/li&gt;
&lt;li&gt;遍历数组，将小于 pivot 的元素放在左边，将大于 pivot 的元素放在右边，pivot 放在中间，此时数组分成了三个部分&lt;/li&gt;
&lt;li&gt;不断重复 2，直到区间缩小为 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（1），是原地排序算法&lt;/li&gt;
&lt;li&gt;最好时间复杂度 O（n log(n)），最坏时间复杂度 O（n^2）（概率很小），平均时间复杂度 O（n log(n)）&lt;/li&gt;
&lt;li&gt;是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/merge_quick.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/merge_quick.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;归并 vs 快排&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;归并 vs 快排&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;堆排序&#34;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://boxtsecond.github.io/zh-cn/dev/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%A0%86/#堆-heap&#34; &gt;堆 Heap&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>常见算法类型（二）排序 O(n^2)：冒泡排序、插入排序、选择排序</title>
        <link>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%BA%8C%E6%8E%92%E5%BA%8F-on2%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 24 Aug 2023 11:25:44 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%BA%8C%E6%8E%92%E5%BA%8F-on2%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
        <description>&lt;h2 id=&#34;冒泡排序-bubble-sort&#34;&gt;冒泡排序 Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/bubble_sort.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/bubble_sort.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;冒泡排序&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;冒泡排序&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;思想说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;冒泡排序中包含两种操作，一种是元素的比较，一种是元素的移动&lt;/li&gt;
&lt;li&gt;冒泡排序只会操作相邻的两个数据，每次冒泡排序操作都会对相邻的两个元素进行比较，若不满足大小关系要求，则互换&lt;/li&gt;
&lt;li&gt;一次冒泡至少会让一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（1），是原地排序算法&lt;/li&gt;
&lt;li&gt;最好时间复杂度 O（n），最坏时间复杂度 O（n^2），平均时间复杂度 O（n^2）&lt;/li&gt;
&lt;li&gt;是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插入排序-insertion-sort&#34;&gt;插入排序 Insertion Sort&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/insert_sort.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/insert_sort.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;插入排序&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;插入排序&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;思想说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入排序包含两种操作，一种是元素的比较，一种是元素的移动&lt;/li&gt;
&lt;li&gt;将数组中的数据分为两个区间，已排序区和未排序区，动态地往有序集合中添加数据&lt;/li&gt;
&lt;li&gt;取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（1），是原地排序算法&lt;/li&gt;
&lt;li&gt;最好时间复杂度 O（n），最坏时间复杂度 O（n^2），平均时间复杂度 O（n^2）&lt;/li&gt;
&lt;li&gt;是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;选择排序-selection-sort&#34;&gt;选择排序 Selection Sort&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/select_sort.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/select_sort.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;选择排序&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;选择排序&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思想说明
&lt;ol&gt;
&lt;li&gt;选择排序包含两种操作，一种是元素的比较，一种是元素的移动&lt;/li&gt;
&lt;li&gt;将数组中的数据，分为已排序区间和未排序区间&lt;/li&gt;
&lt;li&gt;每次从未排序区间中找到最小的元素，放在已排序区间的末尾&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析
&lt;ol&gt;
&lt;li&gt;空间复杂度 O（1），是原地排序算法&lt;/li&gt;
&lt;li&gt;最好时间复杂度 O（n^2），最坏时间复杂度 O（n^2），平均时间复杂度 O（n^2）&lt;/li&gt;
&lt;li&gt;不是稳定的排序算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>常见算法类型（一）排序</title>
        <link>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Thu, 24 Aug 2023 10:25:22 +0800</pubDate>
        
        <guid>https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%8E%92%E5%BA%8F/</guid>
        <description>&lt;h2 id=&#34;如何分析一个排序算法&#34;&gt;如何分析一个排序算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;排序算法的执行效率
&lt;ol&gt;
&lt;li&gt;最好情况、最坏情况、平均情况时间复杂度&lt;/li&gt;
&lt;li&gt;时间复杂度的系数、常数、低阶&lt;/li&gt;
&lt;li&gt;比较次数交换（或移动）次数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;排序算法的内存消耗
&lt;ul&gt;
&lt;li&gt;原地排序，特指空间复杂度是 O（1）的排序算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序算法的稳定性
&lt;ul&gt;
&lt;li&gt;如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，则此排序算法是稳定的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;平均情况时间复杂度的计算&#34;&gt;平均情况时间复杂度的计算&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;有序度
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组中具有有序关系的元素对的个数&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/sort.jpg&#34; &gt;
		&lt;img src=&#34;https://boxtsecond.github.io/zh-cn/dev/algorithm/img/sort.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;有序度&#34;
			width=&#34;85%&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;有序度&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完全有序的数组的有序度叫做满有序度，n*(n-1)/2，如 1，2，3，4，5&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逆序度
&lt;ul&gt;
&lt;li&gt;逆序度 = 满有序度 - 有序度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;排序算法&#34;&gt;排序算法&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%BA%8C%E6%8E%92%E5%BA%8F-on2%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/&#34; &gt;O(n^2)：冒泡排序、插入排序、选择排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%B8%89%E6%8E%92%E5%BA%8F-onlogn%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A0%86%E6%8E%92%E5%BA%8F/&#34; &gt;O(nlogn)：归并排序、快速排序、堆排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E5%9B%9B%E6%8E%92%E5%BA%8F-on%E6%A1%B6%E6%8E%92%E5%BA%8F%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/&#34; &gt;O(n)：桶排序、计数排序、基数排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://boxtsecond.github.io/zh-cn/dev/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E4%BA%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/&#34; &gt;排序算法对比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://boxtsecond.github.io/zh-cn/dev/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95/#拓扑排序-topological-sorting&#34; &gt;Topological Sorting 拓扑排序&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
